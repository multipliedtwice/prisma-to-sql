{
  "meta": {
    "title": "Corrija Consultas Prisma Lentas: Leituras 2‚Äì7√ó Mais R√°pidas (At√© 53,5√ó) | Prisma-SQL",
    "description": "O Prisma est√° lento? Acelere leituras lentas do Prisma em 2‚Äì7√ó sem refatora√ß√µes. Ignore o caminho de execu√ß√£o de leitura do Prisma com execu√ß√£o direta de SQL em PostgreSQL e SQLite (at√© 53,5√ó em filtros de rela√ß√£o no SQLite). Otimiza√ß√£o pronta para produ√ß√£o para workloads Prisma com muitas leituras.",
    "keywords": "slow prisma, prisma slow, prisma performance, fix slow prisma, speed up prisma, prisma optimization, prisma query speed, slow prisma queries, prisma performance issues, make prisma faster, postgresql, sqlite"
  },
  "header": { "cta": "Corrigir Prisma Lento ‚Üí" },
  "hero": {
    "badge": "üöÄ A Solu√ß√£o para Prisma Lento",
    "title": "Corrija Consultas Prisma Lentas",
    "titleHighlight": "Deixe sua API 2‚Äì7√ó Mais R√°pida (At√© 53,5√ó)",
    "description": "O Prisma est√° lento? Voc√™ n√£o est√° sozinho. Gosta do DX do Prisma, mas precisa de mais performance?",
    "descriptionBold": "Acelere consultas Prisma lentas em 2‚Äì7√ó",
    "descriptionSuffix": "(at√© 53,5√ó em filtros de rela√ß√£o no SQLite) sem alterar nenhuma consulta existente.",
    "cta1": "Acelerar Prisma Agora",
    "cta2": "Ver Como Funciona",
    "trustBadges": [
      "Leituras Prisma Mais R√°pidas",
      "Sem Mudan√ßas nas Consultas",
      "Pronto para Produ√ß√£o",
      "137 Testes E2E"
    ],
    "codeTitle": "Corrija Prisma lento em uma linha",
    "codeSnippet": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)\n\nconst users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
  },
  "stats": [
    {
      "value": "2‚Äì7√ó",
      "label": "Leituras Prisma Mais R√°pidas",
      "subtitle": "Acelera√ß√£o t√≠pica",
      "color": "text-accent"
    },
    {
      "value": "0",
      "label": "Mudan√ßas nas Consultas",
      "subtitle": "Mantenha suas chamadas Prisma atuais",
      "color": "text-blue-600"
    },
    {
      "value": "137",
      "label": "Testes E2E",
      "subtitle": "Solu√ß√£o verificada",
      "color": "text-purple-600"
    },
    {
      "value": "100%",
      "label": "Seguran√ßa de Tipos",
      "subtitle": "Mesma API do Prisma",
      "color": "text-pink-600"
    }
  ],
  "problem": {
    "title": "Por que o Prisma √© lento?",
    "subtitle": "Entender a evolu√ß√£o do Prisma e suas caracter√≠sticas de performance ajuda a explicar por que esta extens√£o existe.",
    "historyTitle": "A Jornada do Prisma: DX Primeiro, Performance Importa em Escala",
    "history": [
      {
        "period": "üéØ 2019: O Nascimento do Prisma Moderno",
        "description": "O Prisma 2 foi lan√ßado em 2019, mudando o cen√°rio de ORMs em TypeScript com acesso ao banco com seguran√ßa de tipos e tipos gerados a partir do seu schema. O Prisma introduziu uma arquitetura baseada em engine para traduzir consultas, valid√°-las e fornecer garantias fortes que eram dif√≠ceis de alcan√ßar com ORMs JavaScript tradicionais."
      },
      {
        "period": "‚ö° 2020‚Äì2022: Crescimento R√°pido e Expans√£o de Recursos",
        "description": "O Prisma adicionou recursos poderosos como nested writes, transa√ß√µes e middleware. O conjunto de recursos cresceu, mas cada consulta ainda pagava um custo arquitetural: consultas s√£o representadas, validadas, executadas e os resultados s√£o moldados para corresponder √† API do Prisma."
      },
      {
        "period": "üìä 2023: Overhead Fica Not√°vel em Escala",
        "description": "√Ä medida que mais equipes implantaram o Prisma em workloads de alto tr√°fego, o overhead fixo por consulta tornou-se mensur√°vel. Isso aparece principalmente em endpoints com muitas leituras, analytics, agrega√ß√µes e grandes conjuntos de resultados. O overhead n√£o √© um bug; √© o custo das garantias e do comportamento da API do Prisma."
      },
      {
        "period": "üöÄ 2024‚Äì2025: O Trabalho de Performance do Prisma Continua",
        "description": "O Prisma entregou grandes atualiza√ß√µes focadas em performance e mudan√ßas na engine. Mesmo com melhorias, ainda existe um custo inevit√°vel de parsing, valida√ß√£o, planejamento e formata√ß√£o de resultados em compara√ß√£o com executar SQL bruto diretamente."
      },
      {
        "period": "üéØ 2026: Extens√£o prisma-sql Lan√ßada",
        "description": "Esta extens√£o foca em performance de leitura. Ela contorna o caminho de execu√ß√£o de leitura do Prisma para findMany, findFirst, findUnique, count, aggregate e groupBy, mantendo o Prisma para writes, migrations, gerenciamento de schema e gera√ß√£o de tipos. Valide compatibilidade com sua vers√£o do Prisma antes do rollout."
      }
    ],
    "whyExists": {
      "title": "üí° Por que Esta Extens√£o Existe",
      "description": "O Prisma fez escolhas arquiteturais corretas para seus objetivos: seguran√ßa de tipos, experi√™ncia do desenvolvedor e comportamento consistente entre bancos. Mas essas escolhas criam overhead que fica percept√≠vel em escala. Esta extens√£o n√£o substitui o Prisma ‚Äî ela otimiza leituras para equipes que querem o DX do Prisma com execu√ß√£o mais r√°pida onde importa."
    },
    "technical": [
      {
        "title": "Camada de Tradu√ß√£o de Consultas",
        "description": "O Prisma traduz os inputs da sua consulta para SQL espec√≠fico do banco. Isso habilita comportamento cross-database e a sem√¢ntica da API do Prisma, mas adiciona tempo de processamento antes de o banco ver o SQL.",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Valida√ß√£o e Garantias de Tipo",
        "description": "O Prisma valida consultas contra o schema e imp√µe garantias no n√≠vel da API. Esses mecanismos evitam classes de bugs, mas tamb√©m adicionam overhead a cada consulta.",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Formata√ß√£o de Resultados",
        "description": "Os resultados s√£o moldados para corresponder ao comportamento da API do Prisma. Isso √© √≥timo para DX e consist√™ncia, mas adiciona lat√™ncia, especialmente em grandes conjuntos de resultados e includes complexos.",
        "iconPath": "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
      }
    ],
    "conclusion": "Esta extens√£o complementa o Prisma oferecendo um caminho mais r√°pido para consultas de leitura. Voc√™ mant√©m tudo o que gosta no Prisma e obt√©m leituras 2‚Äì7√ó mais r√°pidas em casos t√≠picos (e at√© 53,5√ó em filtros de rela√ß√£o no SQLite) quando performance importa."
  },
  "performance": {
    "title": "Qu√£o Mais R√°pido? Benchmarks Reais",
    "subtitle": "Veja como esta extens√£o acelera o Prisma em 137 casos de teste",
    "environment": "Ambiente de benchmark: MacBook Pro M1 ‚Ä¢ PostgreSQL 15 ‚Ä¢ SQLite 3.43",
    "metrics": [
      {
        "value": "2.9√ó",
        "label": "Filtros Complexos",
        "subtitle": "Acelera√ß√£o no PostgreSQL",
        "color": "accent"
      },
      {
        "value": "3.0√ó",
        "label": "Includes Aninhados",
        "subtitle": "Acelera√ß√£o no PostgreSQL",
        "color": "blue"
      },
      {
        "value": "7.7√ó",
        "label": "Consultas Simples",
        "subtitle": "Acelera√ß√£o no SQLite",
        "color": "purple"
      },
      {
        "value": "53.5√ó",
        "label": "Filtros de Rela√ß√£o",
        "subtitle": "Acelera√ß√£o no SQLite",
        "color": "pink"
      }
    ],
    "comparisonTitle": "Prisma Padr√£o vs. Prisma-SQL Otimizado",
    "comparisons": [
      {
        "label": "Prisma v7 (Baseline)",
        "time": "2.10ms average",
        "width": 100,
        "bgColor": "bg-gray-400",
        "color": "text-gray-700",
        "bold": false
      },
      {
        "label": "Prisma + Extens√£o (PostgreSQL)",
        "time": "2.10ms ‚Üí 1.00ms (2.10√ó faster) ‚ö°",
        "width": 48,
        "bgColor": "bg-gradient-to-r from-accent to-green-600",
        "color": "text-accent",
        "bold": true
      },
      {
        "label": "Prisma v7 SQLite (Baseline)",
        "time": "5.48ms average",
        "width": 100,
        "bgColor": "bg-gray-400",
        "color": "text-gray-700",
        "bold": false
      },
      {
        "label": "Prisma + Extens√£o (SQLite)",
        "time": "5.48ms ‚Üí 1.00ms (5.48√ó faster) ‚ö°",
        "width": 18,
        "bgColor": "bg-gradient-to-r from-purple-500 to-pink-600",
        "color": "text-purple-600",
        "bold": true
      }
    ],
    "footer": "Compara√ß√£o direta mostrando como esta extens√£o acelera consultas Prisma em opera√ß√µes id√™nticas.",
    "footerLink": "Ver dados completos de benchmark"
  },
  "howItWorks": {
    "title": "Como Ela Otimiza o Prisma",
    "subtitle": "Contorne o caminho de execu√ß√£o de leitura do Prisma mantendo a API e os tipos do Prisma",
    "steps": [
      {
        "title": "Interceptar Consultas do Prisma",
        "description": "A extens√£o captura opera√ß√µes de leitura (findMany, findFirst, findUnique, count, aggregate, groupBy) antes de executar"
      },
      {
        "title": "Gerar SQL Otimizado",
        "description": "Converter consultas Prisma em SQL r√°pido e parametrizado com JOINs otimizados"
      },
      {
        "title": "Executar Diretamente",
        "description": "Rodar consultas via postgres.js ou better-sqlite3, contornando o overhead de leitura do Prisma"
      },
      {
        "title": "Retornar Resultados Compat√≠veis",
        "description": "Os resultados correspondem ao formato esperado pelo Prisma. Tipos, IntelliSense e o c√≥digo de consulta existente permanecem inalterados"
      }
    ],
    "codeExample": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})\n\n// Direct SQL execution for reads\n// Benchmarked around ~1.00ms on this workload\n// Same Prisma query code"
  },
  "features": {
    "title": "Por que Escolher Esta Extens√£o para Prisma?",
    "subtitle": "Obtenha velocidade de execu√ß√£o de SQL bruto para leituras mantendo a experi√™ncia do desenvolvedor do Prisma",
    "items": [
      {
        "title": "Acelera√ß√£o Instant√¢nea do Prisma",
        "description": "Configura√ß√£o √∫nica acelera leituras do Prisma. Sem refatora√ß√£o, sem migra√ß√£o, sem downtime.",
        "color": "accent",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Mantenha Seus Tipos do Prisma",
        "description": "Suporte completo a TypeScript mantido. Infer√™ncia de tipos, autocomplete e seguran√ßa em tempo de compila√ß√£o preservados enquanto as leituras aceleram.",
        "color": "blue",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Solu√ß√£o Testada em Produ√ß√£o",
        "description": "137 testes E2E validam compatibilidade com vers√µes recentes do Prisma. Usada para acelerar leituras do Prisma em apps de produ√ß√£o.",
        "color": "purple",
        "iconPath": "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"
      },
      {
        "title": "Suporte a M√∫ltiplos Bancos",
        "description": "Otimize leituras do Prisma em PostgreSQL (incluindo Neon, Supabase) e SQLite.",
        "color": "pink",
        "iconPath": "M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
      },
      {
        "title": "Op√ß√£o Pr√©-Compilada",
        "description": "Gerador opcional cria SQL em build-time, reduzindo overhead a microssegundos para suas consultas mais cr√≠ticas.",
        "color": "yellow",
        "iconPath": "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
      },
      {
        "title": "Pronto para Serverless (Runtimes Node)",
        "description": "Funciona em runtimes serverless Node. Suporte ao Edge runtime depende de restri√ß√µes do runtime e do driver usado.",
        "color": "green",
        "iconPath": "M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"
      }
    ]
  },
  "useCases": {
    "title": "Quando a Performance do Prisma Importa Mais",
    "subtitle": "Cen√°rios comuns em que esta extens√£o faz diferen√ßa de verdade",
    "cases": [
      {
        "title": "üìä Analytics e Relat√≥rios",
        "description": "Agrega√ß√µes e opera√ß√µes groupBy do Prisma se beneficiam significativamente da execu√ß√£o direta de SQL",
        "color": "blue",
        "benefits": [
          "groupBy 5√ó mais r√°pido acelera relat√≥rios",
          "Consultas aggregate mais r√°pidas",
          "M√©tricas em tempo real com menor lat√™ncia"
        ]
      },
      {
        "title": "üöÄ APIs de Alto Tr√°fego",
        "description": "O overhead por consulta se acumula sob carga, especialmente em endpoints com muitas leituras",
        "color": "purple",
        "benefits": [
          "Menores tempos de resposta da API",
          "Mais requisi√ß√µes por inst√¢ncia",
          "Redu√ß√£o de custos de infraestrutura"
        ]
      },
      {
        "title": "‚òÅÔ∏è Fun√ß√µes Serverless",
        "description": "Cada milissegundo importa em serverless: reduza lat√™ncia de leitura onde conta",
        "color": "green",
        "benefits": [
          "Melhor p95/p99 em leituras",
          "Menores custos com leituras mais r√°pidas",
          "Leituras mais r√°pidas sem refatorar"
        ]
      },
      {
        "title": "üì± Backends Mobile",
        "description": "Usu√°rios percebem lat√™ncia: leituras mais r√°pidas melhoram o UX percebido imediatamente",
        "color": "orange",
        "benefits": [
          "Carregamento de feed mais r√°pido",
          "Pagina√ß√£o mais r√°pida",
          "Intera√ß√µes mais responsivas"
        ]
      }
    ]
  },
  "installation": {
    "title": "Otimize o Prisma em 3 Passos",
    "subtitle": "Acelere leituras do Prisma em menos de 60 segundos",
    "steps": [
      {
        "title": "Instalar a Extens√£o do Prisma",
        "language": "language-bash",
        "code": "# PostgreSQL\nnpm install prisma-sql postgres\n\n# SQLite\nnpm install prisma-sql better-sqlite3"
      },
      {
        "title": "Adicionar a Extens√£o ao Prisma Client",
        "language": "language-typescript",
        "code": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)"
      },
      {
        "title": "Usar o Prisma Normalmente",
        "language": "language-typescript",
        "code": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
      }
    ]
  },
  "faq": {
    "title": "FAQ de Performance do Prisma",
    "subtitle": "Perguntas comuns sobre otimizar leituras do Prisma",
    "questions": [
      {
        "question": "Por que o Prisma tem overhead?",
        "answer": "O Prisma adiciona overhead porque implementa garantias de API como valida√ß√£o baseada em schema, comportamento consistente de consulta e formata√ß√£o de resultados. Essas camadas d√£o uma √≥tima experi√™ncia de desenvolvedor, mas custam tempo em compara√ß√£o com executar SQL bruto diretamente."
      },
      {
        "question": "Como otimizo consultas do Prisma?",
        "answer": "Otimize workloads Prisma com muitas leituras adicionando esta extens√£o. Ela executa leituras via SQL direto usando postgres.js ou better-sqlite3 mantendo a API e os tipos do Prisma. O setup √© uma pequena mudan√ßa de inicializa√ß√£o e n√£o exige refatora√ß√£o das consultas existentes."
      },
      {
        "question": "O Prisma √© mais lento que SQL bruto?",
        "answer": "Para muitos workloads de leitura, sim. Existe overhead arquitetural em compara√ß√£o com execu√ß√£o de SQL bruto. Esta extens√£o busca manter o DX do Prisma reduzindo lat√™ncia de leitura ao executar SQL diretamente."
      },
      {
        "question": "Posso acelerar o Prisma sem mudar consultas existentes?",
        "answer": "Sim. Adicione a extens√£o uma vez durante a inicializa√ß√£o do Prisma Client e mantenha seu c√≥digo de consulta Prisma inalterado. As leituras ficam mais r√°pidas enquanto API, tipos e schema permanecem iguais."
      },
      {
        "question": "Isso funciona em produ√ß√£o?",
        "answer": "Sim. √â validado com 137 testes E2E e projetado para uso em produ√ß√£o. Sempre verifique compatibilidade com sua vers√£o do Prisma e rode seus pr√≥prios testes de regress√£o antes do rollout."
      },
      {
        "question": "O que causa agrega√ß√µes mais lentas no Prisma?",
        "answer": "Agrega√ß√µes e groupBy frequentemente amplificam overhead fixo (processamento de consulta e formata√ß√£o de resultados) e podem envolver conjuntos intermedi√°rios maiores. Esta extens√£o otimiza essas leituras gerando SQL diretamente, o que geralmente reduz lat√™ncia em endpoints com muitas agrega√ß√µes."
      }
    ]
  },
  "cta": {
    "title": "Pronto para Acelerar o Prisma?",
    "subtitle": "Junte-se a devs otimizando leituras do Prisma: 2‚Äì7√ó mais r√°pido (at√© 53,5√ó)",
    "button1": "Instalar Prisma-SQL",
    "button2": "Ver no GitHub"
  },
  "footer": {
    "copyright": "¬© 2026 Prisma-SQL - Acelere leituras do Prisma em 2‚Äì7√ó (at√© 53,5√ó)",
    "tagline": "Tornando o Prisma ainda melhor"
  },
  "testingCallout": {
    "badge": "‚úì Validado",
    "title": "Como garantimos corre√ß√£o?",
    "description": "Cada consulta √© validada contra o Prisma com 137 testes end-to-end em PostgreSQL e SQLite",
    "link": "Ver Metodologia de Testes ‚Üí"
  },
  "testing": {
    "meta": {
      "title": "Metodologia de Testes - Prisma-SQL",
      "description": "Abordagem abrangente: 137 testes E2E garantem que o SQL gerado corresponde exatamente ao output do Prisma",
      "keywords": "prisma testing, sql validation, e2e tests, orm testing, database testing"
    },
    "hero": {
      "badge": "üß™ Garantia de Qualidade",
      "title": "Testes",
      "titleHighlight": "Metodologia",
      "subtitle": "137 testes end-to-end validam que cada SQL gerado corresponde exatamente ao output do Prisma"
    },
    "stats": [
      {
        "value": "137",
        "label": "Testes E2E",
        "description": "Cada consulta validada"
      },
      {
        "value": "100%",
        "label": "Cobertura de Paridade",
        "description": "Correspond√™ncia byte a byte"
      },
      {
        "value": "2",
        "label": "Engines de Banco",
        "description": "PostgreSQL e SQLite"
      },
      {
        "value": "3",
        "label": "Benchmarks de ORM",
        "description": "Prisma v6/v7, Drizzle"
      }
    ],
    "validation": {
      "title": "Como Validamos a Corre√ß√£o",
      "subtitle": "Cada teste segue um processo rigoroso de 5 passos para garantir que o SQL gerado produza resultados id√™nticos ao Prisma",
      "steps": [
        {
          "title": "Gerar SQL a partir da Query do Prisma",
          "description": "Parseie os argumentos da query do Prisma e gere SQL equivalente usando os mesmos models e schema. O SQL gerado usa queries parametrizadas por seguran√ßa e performance."
        },
        {
          "title": "Executar Ambas as Queries em Paralelo",
          "description": "Rode o SQL gerado diretamente via postgres.js ou better-sqlite3 e execute a mesma query via Prisma. Ambos atingem o mesmo estado do banco."
        },
        {
          "title": "Normalizar Resultados",
          "description": "Lide com diferen√ßas de tipos (BigInt vs Number, precis√£o Decimal, serializa√ß√£o de Date) e normalize a ordena√ß√£o de chaves para compara√ß√£o justa."
        },
        {
          "title": "Verifica√ß√£o de Igualdade Profunda",
          "description": "Verifique correspond√™ncia exata: mesma contagem de linhas, mesmos valores, mesmas rela√ß√µes aninhadas, mesma ordena√ß√£o. Qualquer diferen√ßa falha o teste."
        },
        {
          "title": "Benchmark de Performance",
          "description": "Me√ßa tempo de execu√ß√£o com 5 warmups e depois fa√ßa m√©dia de 10‚Äì50 itera√ß√µes por teste. Compare com Prisma v6, Prisma v7 e Drizzle ORM."
        }
      ]
    },
    "advancedTechniques": {
      "title": "T√©cnicas Avan√ßadas de Valida√ß√£o",
      "dataTypes": {
        "title": "Normaliza√ß√£o de Tipos de Dados",
        "items": [
          {
            "label": "BigInt Conversion",
            "description": "JavaScript BigInt ‚Üí Number for comparison"
          },
          {
            "label": "Decimal Handling",
            "description": "Prisma Decimal ‚Üí Float with 10-digit precision"
          },
          {
            "label": "Date Normalization",
            "description": "All DateTime values ‚Üí null (focus on data, not timestamps)"
          },
          {
            "label": "JSON Parsing",
            "description": "Automatic detection and parsing of JSON strings"
          },
          {
            "label": "Object Key Sorting",
            "description": "Alphabetical ordering for consistent comparison"
          }
        ]
      },
      "performance": {
        "title": "Benchmark de Performance",
        "items": [
          {
            "label": "Warmup Phase",
            "description": "5 iterations to prime caches and JIT"
          },
          {
            "label": "Adaptive Iterations",
            "description": "5-50 runs based on query complexity"
          },
          {
            "label": "Isolated Measurement",
            "description": "Each query type measured independently"
          },
          {
            "label": "Multi-ORM Comparison",
            "description": "Prisma v6, v7, Drizzle, Generated SQL"
          },
          {
            "label": "SQL Generation Time",
            "description": "Separate timing for query generation overhead"
          }
        ]
      }
    },
    "coverage": {
      "title": "Cobertura Abrangente de Testes",
      "subtitle": "Testes cobrem todas as opera√ß√µes de leitura do Prisma em m√∫ltiplos n√≠veis de complexidade",
      "categories": [
        {
          "title": "Opera√ß√µes de Query",
          "items": [
            "findMany with complex filters",
            "findFirst with skip & pagination",
            "findUnique by ID & unique fields",
            "count with WHERE conditions",
            "aggregate (sum, avg, min, max)",
            "groupBy with HAVING clauses"
          ]
        },
        {
          "title": "Cen√°rios Complexos",
          "items": [
            "Nested includes (4 levels deep)",
            "Relation filters (some/every/none)",
            "Distinct with window functions",
            "Cursor pagination",
            "Select + include combined",
            "Relation counts (_count)"
          ]
        },
        {
          "title": "Tipos de Filtro",
          "items": [
            "Comparison (lt/lte/gt/gte)",
            "Logical (AND/OR/NOT)",
            "String ops (contains/startsWith)",
            "NULL checks (is/isNot)",
            "IN/NOT IN arrays",
            "Case sensitivity modes"
          ]
        }
      ]
    },
    "databaseSpecific": {
      "postgres": {
        "title": "Testes PostgreSQL",
        "items": [
          "ILIKE case-insensitive searches",
          "JSON/JSONB operations",
          "Array field handling",
          "Composite type support",
          "Window function validation",
          "Transaction isolation testing"
        ]
      },
      "sqlite": {
        "title": "Testes SQLite",
        "items": [
          "LIKE pattern matching",
          "JSON1 extension validation",
          "Window function emulation",
          "DISTINCT optimization",
          "Subquery correlation",
          "Text affinity handling"
        ]
      }
    },
    "example": {
      "title": "Exemplo de Caso de Teste",
      "subtitle": "Veja como validamos uma query aninhada complexa com relation filters",
      "filename": "tests/e2e/postgres.test.ts",
      "code": "it('nested relation filter', () =>\n  runParityTest(\n    db,\n    benchmarkResults,\n    'findMany nested relation',\n    'Organization',\n    {\n      method: 'findMany',\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      }\n    },\n    () => db.prisma.organization.findMany({\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      },\n      orderBy: { id: 'asc' }\n    }),\n  )\n)\n\n// runParityTest internally:\n// 1. Calls generateSQL() with the args\n// 2. Executes generated SQL directly\n// 3. Executes Prisma query\n// 4. Normalizes both results\n// 5. Deep equality check - fails if any difference\n// 6. Benchmarks execution time"
    },
    "executionFlow": {
      "title": "O que Acontece Durante a Execu√ß√£o do Teste",
      "steps": [
        {
          "number": "1",
          "title": "Gera√ß√£o de Query (Microssegundos)",
          "description": "A fun√ß√£o generateSQL() parseia args do Prisma e cria SQL parametrizado. Este passo √© benchmarkado separadamente para medir overhead de gera√ß√£o."
        },
        {
          "number": "2",
          "title": "Execu√ß√£o em Paralelo (Milissegundos)",
          "description": "Ambas as queries atingem o mesmo estado do banco simultaneamente via Promise.all(), garantindo compara√ß√£o justa e condi√ß√µes id√™nticas."
        },
        {
          "number": "3",
          "title": "Normaliza√ß√£o Profunda",
          "description": "Resultados passam por normaliza√ß√£o recursiva: BigInt‚ÜíNumber, Decimal‚ÜíFloat(10), Date‚Üínull, JSON parse, key sorting. Isso garante precis√£o byte a byte."
        },
        {
          "number": "4",
          "title": "Igualdade Estrita",
          "description": "Compara√ß√£o via JSON stringify com toler√¢ncia zero. Qualquer diferen√ßa em contagem de linhas, valores, objetos aninhados ou ordena√ß√£o falha com diff detalhado."
        },
        {
          "number": "5",
          "title": "Medi√ß√£o de Performance",
          "description": "Ap√≥s valida√ß√£o, 5‚Äì50 itera√ß√µes medem tempo m√©dio. Resultados incluem: Prisma v6, Prisma v7, Drizzle ORM, SQL gerado e overhead de gera√ß√£o."
        }
      ]
    },
    "multiVersion": {
      "title": "Valida√ß√£o Multi-Vers√£o",
      "description": "Cada teste roda em Prisma v6 e v7 para garantir compatibilidade entre vers√µes:",
      "v6": {
        "title": "Prisma v6 (6.16.3)",
        "items": [
          "Direct PrismaClient usage",
          "Legacy engine architecture",
          "Baseline performance metrics"
        ]
      },
      "v7": {
        "title": "Prisma v7 (7.2.0)",
        "items": [
          "Adapter-based architecture",
          "@prisma/adapter-pg & adapter-better-sqlite3",
          "New engine optimizations"
        ]
      }
    },
    "benchmarkReports": {
      "title": "Relat√≥rios Autom√°ticos de Benchmark",
      "description": "Todos os resultados de benchmark s√£o gerados automaticamente e armazenados como JSON para transpar√™ncia total:",
      "files": [
        "benchmark-results/v6-postgres-latest.json",
        "benchmark-results/v7-postgres-latest.json",
        "benchmark-results/v6-sqlite-latest.json",
        "benchmark-results/v7-sqlite-latest.json"
      ],
      "footer": "Cada arquivo cont√©m: nome do teste, tempo do Prisma, tempo do SQL gerado, tempo do Drizzle, speedup ratios e timestamp ISO."
    },
    "cta": {
      "title": "Explore a Su√≠te Completa de Testes",
      "subtitle": "Todos os 137 testes s√£o open source. Revise o c√≥digo, benchmarks e l√≥gica de valida√ß√£o.",
      "button1": "Ver Su√≠te de Testes ‚Üí",
      "button2": "Ver Benchmarks"
    }
  },
  "sqlPrevention": {
    "meta": {
      "title": "Preven√ß√£o de SQL Injection - Seguran√ßa do Prisma-SQL",
      "description": "Metodologia de preven√ß√£o de SQL injection usando parameter binding, valida√ß√£o baseada em schema e 137 testes focados em seguran√ßa (su√≠te atual)",
      "keywords": "sql injection prevention, parameterized queries, sql security, database security, prisma security"
    },
    "hero": {
      "badge": "üîí Seguran√ßa em Primeiro Lugar",
      "title": "SQL Injection",
      "titleHighlight": "Preven√ß√£o",
      "subtitle": "Valores fornecidos pelo usu√°rio nunca s√£o interpolados no texto SQL ‚Äî os valores s√£o vinculados via placeholders de par√¢metros (dependente do dialeto, ex.: $1 ou ?)"
    },
    "stats": [
      {
        "value": "100%",
        "label": "Par√¢metros Vinculados",
        "description": "Todos os valores do usu√°rio usam placeholders"
      },
      {
        "value": "Zero",
        "label": "Interpola√ß√£o de Valores",
        "description": "Dados do usu√°rio nunca aparecem no texto SQL"
      },
      {
        "value": "Garantido",
        "label": "Preserva√ß√£o de Ordem",
        "description": "Placeholders mapeiam params 1:1"
      },
      {
        "value": "137",
        "label": "Testes de Seguran√ßa",
        "description": "Cobertura de tentativas de injection (su√≠te atual)"
      }
    ],
    "threat": {
      "title": "Entendendo SQL Injection",
      "subtitle": "SQL injection continua sendo uma das vulnerabilidades mais cr√≠ticas em aplica√ß√µes web",
      "description": "SQL injection ocorre quando dados n√£o confi√°veis s√£o incorporados no texto SQL sem parameter binding seguro. Atacantes podem manipular o significado da query para acessar dados n√£o autorizados, modificar registros ou disparar opera√ß√µes n√£o intencionais.",
      "examples": {
        "title": "Padr√µes Comuns de Ataque",
        "items": [
          {
            "name": "Authentication Bypass",
            "attack": "admin' OR '1'='1",
            "description": "Attempts to bypass login by making the WHERE condition always true"
          },
          {
            "name": "Data Exfiltration",
            "attack": "' UNION SELECT password FROM users--",
            "description": "Uses UNION to attempt extracting data from other tables"
          },
          {
            "name": "Destructive Commands",
            "attack": "'; DROP TABLE users; --",
            "description": "Attempts to append extra statements to delete data"
          },
          {
            "name": "Parameter Order Bug Abuse",
            "attack": "Exploit: If placeholders and params are mismatched, authorization checks may use the wrong values",
            "description": "Example: WHERE userId=$1 AND isAdmin=$2, but params=[true, 123] instead of [123, true] can incorrectly grant admin access"
          }
        ]
      }
    },
    "protection": {
      "title": "Estrat√©gia de Prote√ß√£o em M√∫ltiplas Camadas",
      "subtitle": "Cada query passa por m√∫ltiplas camadas de valida√ß√£o de seguran√ßa",
      "layers": [
        {
          "title": "Camada 1: Parameter Binding Autom√°tico",
          "description": "Todos os valores do usu√°rio s√£o convertidos em par√¢metros vinculados. Valores n√£o entram no texto SQL como literais.",
          "guarantees": [
            "User values are represented using dialect-specific placeholders (e.g. $1 or ?)",
            "Array inputs are parameterized (expanded placeholders or array parameters depending on dialect/strategy)",
            "NULL and optional values handled without concatenating user input into SQL text",
            "Date/time values are parameterized",
            "JSON values are parameterized"
          ]
        },
        {
          "title": "Camada 2: Valida√ß√£o de Nomes de Campo",
          "description": "Cada nome de campo √© validado contra o metadata do schema Prisma antes da gera√ß√£o do SQL.",
          "guarantees": [
            "Only schema-defined fields are allowed",
            "Relation filters validated via schema metadata",
            "No arbitrary field names accepted",
            "Unsupported/computed fields rejected where applicable",
            "Prototype pollution payloads are rejected (e.g. __proto__, constructor)"
          ]
        },
        {
          "title": "Camada 3: Sanitiza√ß√£o de Identificadores",
          "description": "Nomes de tabelas, colunas e aliases s√£o validados e corretamente quoted/escaped quando necess√°rio.",
          "guarantees": [
            "Control characters rejected",
            "Reserved keywords are quoted when needed",
            "Schema qualification supported where configured",
            "Double-quote escaping (or dialect equivalent) for identifiers",
            "Maximum identifier length enforced per dialect"
          ]
        },
        {
          "title": "Camada 4: Valida√ß√£o de Operadores",
          "description": "Apenas operadores conhecidos e seguros s√£o permitidos para cada tipo de campo.",
          "guarantees": [
            "String operators: contains, startsWith, endsWith",
            "Numeric operators: lt, lte, gt, gte",
            "Array operators: in, notIn with type validation",
            "Logical operators: AND, OR, NOT validated structurally",
            "Unknown operators rejected immediately"
          ]
        },
        {
          "title": "Camada 5: Garantia de Ordem de Par√¢metros",
          "description": "Ordena√ß√£o estrita garante que cada placeholder mapeia para exatamente um par√¢metro na ordem de inser√ß√£o, evitando mismatches.",
          "guarantees": [
            "Sequential counter prevents reordering",
            "Lockstep SQL building and param array construction",
            "No intermediate buffer or reordering operations",
            "Test verification: generated SQL and params always align",
            "One-to-one correspondence: placeholder N ‚Üí params[N-1] (or equivalent mapping for the dialect)"
          ]
        }
      ]
    },
    "formalProofs": {
      "title": "Garantias Formais de Seguran√ßa",
      "subtitle": "Proof sketches para resist√™ncia a injection sob as suposi√ß√µes do design (parameter binding, sem bypass raw-SQL, uso correto do driver)",
      "proofs": [
        {
          "title": "Theorem 1: Value Isolation",
          "statement": "For all user-provided values V, there exists no execution path where V appears as SQL text in the generated query string.",
          "proof": "By construction, all code paths that handle user values call addParameter(value) which:\n1. Stores the value in a separate params array\n2. Returns a placeholder token for the SQL text\n3. Only the placeholder token is appended into the SQL string\n4. The database driver receives SQL text and parameter values separately\n‚à¥ User values are not parsed as SQL syntax",
          "code": "const addParameter = (params: any[], value: any) => {\n  params.push(value)\n  const index = params.length\n  return `$${index}`\n}"
        },
        {
          "title": "Theorem 2: Field Name Closure",
          "statement": "The set of field names F in any generated query is a subset of schema-defined fields S, i.e., F ‚äÜ S.",
          "proof": "For every field reference:\n1. Field name extracted from query object\n2. Lookup performed against schema metadata\n3. If the field does not exist in the schema, an error is thrown\n4. Only validated fields reach SQL generation\n‚à¥ Arbitrary field names cannot appear in SQL",
          "code": "const validateField = (field: string, model: Model) => {\n  if (!model.fields.has(field)) {\n    throw new Error(`Field ${field} does not exist`)\n  }\n  return model.fields.get(field)\n}"
        },
        {
          "title": "Theorem 3: Operator Safety",
          "statement": "For any operator O applied to field F, O is a member of the allowed operators for F's type T.",
          "proof": "Operator validation algorithm:\n1. Extract field type T from schema\n2. Define allowed_ops(T) = { valid operators for type T }\n3. For operator O in query:\n   - If O ‚àâ allowed_ops(T), throw error\n   - Else apply operator using parameter binding\n‚à¥ Only type-appropriate operators can be used",
          "code": "const ALLOWED_OPS: Record<string, string[]> = {\n  String: ['contains', 'startsWith', 'endsWith'],\n  Int: ['lt', 'lte', 'gt', 'gte']\n}\nif (!ALLOWED_OPS[fieldType]?.includes(operator)) {\n  throw new Error('Invalid operator')\n}"
        },
        {
          "title": "Theorem 4: Identifier Safety",
          "statement": "All SQL identifiers I are validated to prevent control characters and to ensure safe quoting/escaping per dialect.",
          "proof": "Identifier processing:\n1. Reject if contains control characters\n2. Escape internal quote characters per dialect rules\n3. Quote identifiers when required (reserved keywords or special characters)\n4. Enforce per-dialect identifier length limits\n‚à¥ Identifiers cannot break SQL syntax or introduce injected tokens",
          "code": "const quoteIdentifier = (id: string) => {\n  if (/[\\x00-\\x1F]/.test(id)) {\n    throw new Error('Invalid characters')\n  }\n  const escaped = id.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(id) || isReservedKeyword(id)\n  return needsQuoting ? `\"${escaped}\"` : id\n}"
        },
        {
          "title": "Theorem 5: Parameter Order Consistency",
          "statement": "For every placeholder position N emitted into the SQL text, params[N-1] contains the exact value intended for that position, with no reordering or mismatch.",
          "proof": "Parameter ordering guarantee:\n1. A single tracker maintains insertion order\n2. Each add() call appends the value to params and immediately emits the next placeholder token\n3. SQL text construction and params construction proceed in lockstep\n4. No intermediate reordering operations occur\n‚à¥ One-to-one correspondence is maintained throughout",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}\n\nconst tracker = new ParameterTracker()\nconst sql = `WHERE email = ${tracker.add(email)} AND age > ${tracker.add(age)}`\nconst params = tracker.getParams()"
        }
      ]
    },
    "testCoverage": {
      "title": "Cobertura Abrangente de Testes de Seguran√ßa",
      "subtitle": "137 testes validam prote√ß√£o contra vetores comuns de SQL injection e edge cases (su√≠te atual)",
      "categories": [
        {
          "title": "Value Parameterization (basic.test.ts)",
          "tests": [
            "Strings with quotes: user'with'quotes",
            "Strings with semicolons: user;extra",
            "SQL keywords as values: DROP TABLE users",
            "Complex injection: '; DROP TABLE users; --",
            "Union attacks: ' UNION SELECT * FROM users--",
            "Boolean attacks: admin' OR '1'='1",
            "Comment injection: test@example.com' -- comment"
          ]
        },
        {
          "title": "Field Name Validation (identifiers.test.ts)",
          "tests": [
            "Reject malicious field names in SELECT",
            "Reject malicious field names in WHERE",
            "Reject malicious field names in ORDER BY",
            "Reject SQL injection in field names",
            "Reject non-existent fields",
            "Reject prototype pollution: __proto__, constructor"
          ]
        },
        {
          "title": "LIKE Pattern Safety (like-patterns.test.ts)",
          "tests": [
            "Wildcard injection: %' OR '1'='1",
            "Underscore injection: test_' OR '1'='1",
            "Backslash handling: test\\\\'; DROP--",
            "Multiple wildcards: %_%'; DROP--",
            "Case insensitive injection: '; UNION SELECT--"
          ]
        },
        {
          "title": "Array Operator Safety (array-operators.test.ts)",
          "tests": [
            "IN with malicious arrays: ['; DROP--', 'UNION SELECT--']",
            "NOT IN with injection: ['; TRUNCATE--', 'DELETE FROM--']",
            "Empty array handling",
            "Large array validation (100+ items)",
            "Mixed type array handling"
          ]
        },
        {
          "title": "Edge Cases (edge-cases.test.ts)",
          "tests": [
            "Unicode injection: \\u0027 OR \\u00271\\u0027=\\u00271",
            "Hex-encoded injection: 0x31=0x31--",
            "URL encoded: %27%3B%20DROP%20TABLE",
            "Stacked queries: '; DROP TABLE users; SELECT",
            "Time-based blind (dialect-specific): WAITFOR DELAY '00:00:05'--",
            "UNION-based: UNION ALL SELECT null, password",
            "Second-order injection attempts"
          ]
        },
        {
          "title": "Parameter Order Verification (basic.test.ts)",
          "tests": [
            "Sequential placeholder positions",
            "Parameter array matches placeholder order",
            "Complex queries maintain order across conditions",
            "Nested OR/AND conditions preserve parameter sequence",
            "Relation filters maintain correct parameter mapping"
          ]
        }
      ]
    },
    "codeExamples": {
      "title": "Seguro vs. Inseguro: Compara√ß√£o de C√≥digo",
      "unsafe": {
        "title": "‚ùå Inseguro: Concatena√ß√£o de String",
        "code": "const email = req.body.email\nconst sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\""
      },
      "safe": {
        "title": "‚úÖ Seguro: Parameter Binding Autom√°tico",
        "code": "const email = req.body.email\nconst { sql, params } = toSQL('User', 'findMany', {\n  where: { email }\n})\n\nconst result = { sql, params }"
      }
    },
    "implementation": {
      "title": "Detalhes de Implementa√ß√£o",
      "sections": [
        {
          "title": "Gerenciamento de Par√¢metros",
          "description": "Rastreamento centralizado garante que cada valor do usu√°rio seja parametrizado e preserve a ordem",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}"
        },
        {
          "title": "Valida√ß√£o de Campos",
          "description": "Valida√ß√£o baseada em schema impede acesso arbitr√°rio a campos",
          "code": "function validateField(\n  fieldName: string,\n  model: ModelInfo\n): FieldInfo {\n  const field = model.fields.get(fieldName)\n  if (!field) {\n    throw new Error(\n      `Field \"${fieldName}\" does not exist`\n    )\n  }\n  return field\n}"
        },
        {
          "title": "Quoting de Identificadores",
          "description": "Valida√ß√£o e quoting por dialeto previnem injection via identificadores",
          "code": "function quoteIdentifier(identifier: string): string {\n  if (/[\\x00-\\x1F]/.test(identifier)) {\n    throw new Error('Invalid control characters')\n  }\n\n  const escaped = identifier.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(identifier) || isReservedKeyword(identifier)\n\n  if (needsQuoting) {\n    return `\"${escaped}\"`\n  }\n\n  return identifier\n}"
        }
      ]
    },
    "bestPractices": {
      "title": "Boas Pr√°ticas de Seguran√ßa",
      "practices": [
        {
          "title": "Nunca Desative Valida√ß√µes",
          "description": "N√£o fa√ßa bypass de valida√ß√£o de schema ou checagem de campos. S√£o camadas cr√≠ticas de seguran√ßa.",
          "do": "Use a biblioteca como foi projetada, com valida√ß√£o completa",
          "dont": "Bypass schema validation ou injete SQL bruto no texto da query"
        },
        {
          "title": "Mantenha o Schema Atualizado",
          "description": "Garanta que seu schema Prisma reflita com precis√£o a estrutura do banco.",
          "do": "Rode prisma db pull e prisma generate ap√≥s mudan√ßas no schema",
          "dont": "Use DMMF ou defini√ß√µes de schema desatualizadas"
        },
        {
          "title": "Valide Tipos de Input",
          "description": "TypeScript oferece seguran√ßa em tempo de compila√ß√£o, mas valida√ß√£o em runtime adiciona defesa em profundidade.",
          "do": "Use os tipos gerados pelo Prisma para args de query",
          "dont": "Converta input do usu√°rio para any antes de passar para queries"
        },
        {
          "title": "Monitore Padr√µes de Query",
          "description": "Registre e monitore SQL gerado e par√¢metros em produ√ß√£o para detectar anomalias e mau uso.",
          "do": "Ative query logging e revise padr√µes",
          "dont": "Rode em produ√ß√£o sem monitoramento"
        }
      ]
    },
    "securityCallout": {
      "badge": "üîí Seguran√ßa Verificada",
      "title": "Como evitamos SQL injection?",
      "description": "Valida√ß√£o em m√∫ltiplas camadas com parameter binding, checagem de campos baseada em schema e 137 testes de seguran√ßa (su√≠te atual)",
      "link": "Ver Detalhes de Seguran√ßa ‚Üí"
    },
    "cta": {
      "title": "Seguran√ßa por Design",
      "subtitle": "A prote√ß√£o contra SQL injection est√° embutida em cada camada desta biblioteca. Revise os testes de seguran√ßa e detalhes de implementa√ß√£o diretamente.",
      "button1": "Ver Testes de Seguran√ßa ‚Üí",
      "button2": "Ver C√≥digo Fonte"
    }
  }
}
