{
  "meta": {
    "title": "Arregla consultas lentas de Prisma: lecturas 2‚Äì7√ó m√°s r√°pidas (hasta 53.5√ó) | Prisma-SQL",
    "description": "¬øPrisma va lento? Acelera lecturas lentas de Prisma 2‚Äì7√ó sin refactors. Evita la ruta de ejecuci√≥n de lecturas de Prisma con ejecuci√≥n SQL directa en PostgreSQL y SQLite (hasta 53.5√ó en filtros de relaci√≥n de SQLite). Optimizaci√≥n lista para producci√≥n para cargas de trabajo de Prisma centradas en lecturas.",
    "keywords": "prisma lento, prisma es lento, rendimiento prisma, arreglar prisma lento, acelerar prisma, optimizaci√≥n prisma, velocidad de consultas prisma, consultas lentas prisma, problemas de rendimiento prisma, hacer prisma m√°s r√°pido, postgresql, sqlite"
  },
  "header": {
    "cta": "Arreglar Prisma lento ‚Üí"
  },
  "hero": {
    "badge": "üöÄ La soluci√≥n para Prisma lento",
    "title": "Arregla consultas lentas de Prisma",
    "titleHighlight": "Haz tu API 2‚Äì7√ó m√°s r√°pida (hasta 53.5√ó)",
    "description": "¬øPrisma va lento? No est√°s solo. ¬øTe encanta el DX de Prisma pero necesitas mejor rendimiento?",
    "descriptionBold": "Acelera consultas lentas de Prisma 2‚Äì7√ó",
    "descriptionSuffix": "(hasta 53.5√ó en filtros de relaci√≥n de SQLite) sin cambiar ninguna consulta existente.",
    "cta1": "Acelerar Prisma ahora",
    "cta2": "Ver c√≥mo funciona",
    "trustBadges": [
      "Lecturas de Prisma m√°s r√°pidas",
      "Sin cambios de consulta",
      "Listo para producci√≥n",
      "137 pruebas E2E"
    ],
    "codeTitle": "Arregla Prisma lento en una l√≠nea",
    "codeSnippet": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)\n\nconst users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
  },
  "stats": [
    {
      "value": "2‚Äì7√ó",
      "label": "Lecturas de Prisma m√°s r√°pidas",
      "subtitle": "Aceleraci√≥n t√≠pica",
      "color": "text-accent"
    },
    {
      "value": "0",
      "label": "Cambios de consulta",
      "subtitle": "Mant√©n tus llamadas Prisma existentes",
      "color": "text-blue-600"
    },
    {
      "value": "137",
      "label": "Pruebas E2E",
      "subtitle": "Soluci√≥n verificada",
      "color": "text-purple-600"
    },
    {
      "value": "100%",
      "label": "Seguridad de tipos",
      "subtitle": "La misma API de Prisma",
      "color": "text-pink-600"
    }
  ],
  "problem": {
    "title": "¬øPor qu√© Prisma es lento?",
    "subtitle": "Entender la evoluci√≥n de Prisma y sus caracter√≠sticas de rendimiento ayuda a explicar por qu√© existe esta extensi√≥n.",
    "historyTitle": "El recorrido de Prisma: DX primero, el rendimiento importa a escala",
    "history": [
      {
        "period": "üéØ 2019: El nacimiento de Prisma moderno",
        "description": "Prisma 2 se lanz√≥ en 2019, cambiando el panorama de ORMs en TypeScript con acceso a base de datos con seguridad de tipos y tipos generados desde tu esquema. Prisma introdujo una arquitectura basada en engine para traducir consultas, validarlas y ofrecer garant√≠as fuertes que eran dif√≠ciles de lograr con ORMs tradicionales de JavaScript."
      },
      {
        "period": "‚ö° 2020‚Äì2022: Crecimiento r√°pido y expansi√≥n de funcionalidades",
        "description": "Prisma a√±adi√≥ funciones potentes como escrituras anidadas, transacciones y middleware. El conjunto de funciones creci√≥, pero cada consulta segu√≠a pagando un coste arquitect√≥nico: las consultas se representan, validan, ejecutan y los resultados se moldean para coincidir con la API de Prisma."
      },
      {
        "period": "üìä 2023: La sobrecarga se vuelve notable a escala",
        "description": "A medida que m√°s equipos desplegaron Prisma en cargas de trabajo de alto tr√°fico, la sobrecarga fija por consulta se volvi√≥ medible. Esto se ve especialmente en endpoints con muchas lecturas, anal√≠tica, agregaciones y conjuntos de resultados grandes. La sobrecarga no es un bug; es el coste de las garant√≠as y el comportamiento de la API de Prisma."
      },
      {
        "period": "üöÄ 2024‚Äì2025: Contin√∫a el trabajo de rendimiento en Prisma",
        "description": "Prisma public√≥ actualizaciones importantes centradas en rendimiento y cambios del engine. Incluso con mejoras, sigue existiendo un coste inevitable por parsear, validar, planificar y moldear resultados frente a ejecutar SQL crudo directamente."
      },
      {
        "period": "üéØ 2026: Se lanza la extensi√≥n prisma-sql",
        "description": "Esta extensi√≥n se centra en el rendimiento de lectura. Evita la ruta de ejecuci√≥n de lecturas de Prisma para findMany, findFirst, findUnique, count, aggregate y groupBy, mientras mantiene Prisma para escrituras, migraciones, gesti√≥n de esquema y generaci√≥n de tipos. Valida la compatibilidad con tu versi√≥n de Prisma antes del despliegue."
      }
    ],
    "whyExists": {
      "title": "üí° Por qu√© existe esta extensi√≥n",
      "description": "Prisma tom√≥ las decisiones arquitect√≥nicas correctas para sus objetivos: seguridad de tipos, experiencia de desarrollo y comportamiento consistente entre bases de datos. Pero esas decisiones crean una sobrecarga que se nota a escala. Esta extensi√≥n no reemplaza Prisma: optimiza lecturas para equipos que quieren el DX de Prisma m√°s ejecuci√≥n m√°s r√°pida donde importa."
    },
    "technical": [
      {
        "title": "Capa de traducci√≥n de consultas",
        "description": "Prisma traduce los inputs de tu consulta a SQL espec√≠fico del motor. Esto permite comportamiento consistente entre bases de datos y la sem√°ntica de la API de Prisma, pero a√±ade tiempo de procesamiento antes de que la base de datos vea el SQL.",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Validaci√≥n y garant√≠as de tipos",
        "description": "Prisma valida consultas contra el esquema y aplica garant√≠as a nivel de API. Estas salvaguardas previenen clases de bugs, pero tambi√©n a√±aden sobrecarga a cada consulta.",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Moldeado de resultados",
        "description": "Los resultados se moldean para coincidir con el comportamiento esperado de la API de Prisma. Esto es excelente para DX y consistencia, pero a√±ade latencia, especialmente en conjuntos de resultados grandes e includes complejos.",
        "iconPath": "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
      }
    ],
    "conclusion": "Esta extensi√≥n complementa Prisma ofreciendo una ruta m√°s r√°pida para consultas de lectura. Conservas todo lo que te gusta de Prisma y obtienes lecturas 2‚Äì7√ó m√°s r√°pidas en casos t√≠picos (y hasta 53.5√ó en filtros de relaci√≥n de SQLite) cuando el rendimiento importa."
  },
  "performance": {
    "title": "¬øCu√°nto m√°s r√°pido? Benchmarks reales",
    "subtitle": "Comparaci√≥n completa entre Prisma v6, v7, Drizzle ORM y Prisma-SQL",
    "environment": "Entorno de benchmark: MacBook Pro M1 ‚Ä¢ PostgreSQL 15 ‚Ä¢ SQLite 3.43 ‚Ä¢ 137 casos de prueba por base de datos",
    "databases": [
      {
        "name": "PostgreSQL",
        "color": "accent",
        "subtitle": "Promedio en 57 casos de prueba",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "2.10ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "1.95ms",
            "width": 93,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.08√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "1.40ms",
            "width": 67,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.50√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.90ms",
            "width": 43,
            "bgColor": "bg-gradient-to-r from-accent to-green-600",
            "color": "text-accent",
            "speedup": "2.34√ó"
          }
        ],
        "highlights": [
          {
            "label": "Distinct Queries",
            "value": "6.3√ó",
            "description": "vs Prisma v6"
          },
          {
            "label": "Relation Filters",
            "value": "5.5√ó",
            "description": "vs Prisma v6 (\"none\"-filtro)"
          }
        ]
      },
      {
        "name": "SQLite",
        "color": "purple",
        "subtitle": "Promedio en 56 casos de prueba",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "5.48ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "4.12ms",
            "width": 75,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.33√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "2.11ms",
            "width": 39,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "2.60√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.73ms",
            "width": 13,
            "bgColor": "bg-gradient-to-r from-purple-500 to-pink-600",
            "color": "text-purple-600",
            "speedup": "7.50√ó"
          }
        ],
        "highlights": [
          {
            "label": "Simple Queries",
            "value": "12.6√ó",
            "description": "vs Prisma v6"
          },
          {
            "label": "Relation Filters",
            "value": "69.7√ó",
            "description": "vs Prisma v6 (\"none\"-filtro)"
          }
        ]
      }
    ],
    "footer": "Benchmarks basados en 137 pruebas E2E por base de datos. Prisma v6.16.3, Prisma v7.2.0, Drizzle ORM latest.",
    "footerLink": "Ver datos completos del benchmark"
  },
  "howItWorks": {
    "title": "C√≥mo optimiza Prisma",
    "subtitle": "Evita la ruta de ejecuci√≥n de lecturas de Prisma manteniendo la API y los tipos de Prisma",
    "steps": [
      {
        "title": "Interceptar consultas de Prisma",
        "description": "La extensi√≥n captura operaciones de lectura (findMany, findFirst, findUnique, count, aggregate, groupBy) antes de que se ejecuten"
      },
      {
        "title": "Generar SQL optimizado",
        "description": "Convierte consultas Prisma en SQL r√°pido y parametrizado con JOINs optimizados"
      },
      {
        "title": "Ejecutar directamente",
        "description": "Ejecuta consultas mediante postgres.js o better-sqlite3, evitando la sobrecarga de lectura de Prisma"
      },
      {
        "title": "Devolver resultados compatibles",
        "description": "Los resultados coinciden con la forma esperada por Prisma. Tipos, IntelliSense y el c√≥digo de consultas existente permanecen sin cambios"
      }
    ],
    "codeExample": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})\n\n// Direct SQL execution for reads\n// Benchmarked around ~1.00ms on this workload\n// Same Prisma query code"
  },
  "features": {
    "title": "¬øPor qu√© elegir esta extensi√≥n de Prisma?",
    "subtitle": "Obt√©n velocidad de ejecuci√≥n de SQL crudo para lecturas manteniendo la experiencia de desarrollo de Prisma",
    "items": [
      {
        "title": "Aceleraci√≥n instant√°nea de Prisma",
        "description": "Una configuraci√≥n √∫nica acelera lecturas de Prisma. Sin refactor, sin migraci√≥n, sin downtime.",
        "color": "accent",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Mant√©n tus tipos de Prisma",
        "description": "Compatibilidad completa con TypeScript. Inferencia de tipos, autocompletado y seguridad en compilaci√≥n preservados mientras se aceleran lecturas.",
        "color": "blue",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Soluci√≥n probada en producci√≥n",
        "description": "137 pruebas E2E validan compatibilidad con versiones recientes de Prisma. Usada para acelerar lecturas de Prisma en apps de producci√≥n.",
        "color": "purple",
        "iconPath": "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"
      },
      {
        "title": "Soporte para m√∫ltiples bases de datos",
        "description": "Optimiza lecturas de Prisma en PostgreSQL (incluido Neon, Supabase) y SQLite.",
        "color": "pink",
        "iconPath": "M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
      },
      {
        "title": "Opci√≥n precompilada",
        "description": "Un generador opcional crea SQL en build-time, reduciendo la sobrecarga a microsegundos para tus consultas m√°s calientes.",
        "color": "yellow",
        "iconPath": "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
      },
      {
        "title": "Listo para serverless (runtimes Node)",
        "description": "Funciona en runtimes serverless de Node. El soporte para Edge runtime depende de las restricciones del runtime y del driver que uses.",
        "color": "green",
        "iconPath": "M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"
      }
    ]
  },
  "useCases": {
    "title": "Cu√°ndo el rendimiento de Prisma importa m√°s",
    "subtitle": "Escenarios comunes donde esta extensi√≥n marca una diferencia real",
    "cases": [
      {
        "title": "üìä Anal√≠tica e informes",
        "description": "Las agregaciones y operaciones groupBy de Prisma se benefician significativamente de la ejecuci√≥n SQL directa",
        "color": "blue",
        "benefits": [
          "groupBy 5√ó m√°s r√°pido acelera informes",
          "Consultas aggregate m√°s r√°pidas",
          "M√©tricas en tiempo real con menor latencia"
        ]
      },
      {
        "title": "üöÄ APIs de alto tr√°fico",
        "description": "La sobrecarga por consulta se acumula bajo carga, especialmente en endpoints con muchas lecturas",
        "color": "purple",
        "benefits": [
          "Menores tiempos de respuesta de la API",
          "Manejar m√°s solicitudes por instancia",
          "Reducir costos de infraestructura"
        ]
      },
      {
        "title": "‚òÅÔ∏è Funciones serverless",
        "description": "Cada milisegundo cuenta en serverless: reduce latencia de lectura donde importa",
        "color": "green",
        "benefits": [
          "Mejor p95/p99 en lecturas",
          "Menor costo mediante lecturas m√°s r√°pidas",
          "Lecturas m√°s r√°pidas sin refactors"
        ]
      },
      {
        "title": "üì± Backends m√≥viles",
        "description": "Los usuarios notan la latencia: lecturas m√°s r√°pidas mejoran el UX percibido de inmediato",
        "color": "orange",
        "benefits": [
          "Carga de feed m√°s r√°pida",
          "Paginaci√≥n m√°s r√°pida",
          "Interacciones m√°s responsivas"
        ]
      }
    ]
  },
  "installation": {
    "title": "Optimiza Prisma en 3 pasos",
    "subtitle": "Acelera lecturas de Prisma en menos de 60 segundos",
    "steps": [
      {
        "title": "Instala la extensi√≥n de Prisma",
        "language": "language-bash",
        "code": "# PostgreSQL\nnpm install prisma-sql postgres\n\n# SQLite\nnpm install prisma-sql better-sqlite3"
      },
      {
        "title": "A√±ade la extensi√≥n al cliente de Prisma",
        "language": "language-typescript",
        "code": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)"
      },
      {
        "title": "Usa Prisma normalmente",
        "language": "language-typescript",
        "code": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
      }
    ]
  },
  "faq": {
    "title": "FAQ de rendimiento de Prisma",
    "subtitle": "Preguntas comunes sobre c√≥mo optimizar lecturas en Prisma",
    "questions": [
      {
        "question": "¬øPor qu√© Prisma tiene sobrecarga?",
        "answer": "Prisma a√±ade sobrecarga porque implementa garant√≠as de API como validaci√≥n basada en el esquema, comportamiento de consulta consistente y moldeado de resultados. Esas capas ofrecen una gran experiencia de desarrollo, pero cuestan tiempo comparado con ejecutar SQL crudo directamente."
      },
      {
        "question": "¬øC√≥mo optimizo consultas de Prisma?",
        "answer": "Optimiza cargas de trabajo de Prisma centradas en lecturas a√±adiendo esta extensi√≥n. Ejecuta operaciones de lectura mediante SQL directo con postgres.js o better-sqlite3, manteniendo la API y los tipos de Prisma. La configuraci√≥n es un peque√±o cambio de inicializaci√≥n y no requiere refactor de tus consultas existentes."
      },
      {
        "question": "¬øPrisma es m√°s lento que SQL crudo?",
        "answer": "Para muchas cargas de lectura, s√≠. Hay una sobrecarga arquitect√≥nica frente a ejecutar SQL crudo. Esta extensi√≥n busca mantener el DX de Prisma reduciendo la latencia de lectura mediante ejecuci√≥n SQL directa."
      },
      {
        "question": "¬øPuedo acelerar Prisma sin cambiar consultas existentes?",
        "answer": "S√≠. A√±ade la extensi√≥n una vez durante la inicializaci√≥n del Prisma Client y mant√©n tu c√≥digo de consultas Prisma sin cambios. Las operaciones de lectura se ejecutan m√°s r√°pido mientras tu API, tipos y esquema de Prisma permanecen igual."
      },
      {
        "question": "¬øEsto funciona en producci√≥n?",
        "answer": "S√≠. Est√° validado con 137 pruebas E2E y est√° dise√±ado para usarse en producci√≥n. Verifica siempre la compatibilidad con tu versi√≥n de Prisma y ejecuta tus propias pruebas de regresi√≥n antes del despliegue."
      },
      {
        "question": "¬øQu√© causa agregaciones m√°s lentas en Prisma?",
        "answer": "Las agregaciones y groupBy a menudo amplifican la sobrecarga fija (procesamiento de consulta y moldeado de resultados) y pueden involucrar conjuntos de resultados intermedios m√°s grandes. Esta extensi√≥n optimiza esas lecturas generando SQL directamente, lo que t√≠picamente reduce la latencia en endpoints con muchas agregaciones."
      }
    ]
  },
  "cta": {
    "title": "¬øListo para acelerar Prisma?",
    "subtitle": "√önete a desarrolladores que optimizan lecturas de Prisma: 2‚Äì7√ó m√°s r√°pido (hasta 53.5√ó)",
    "button1": "Instalar Prisma-SQL",
    "button2": "Ver en GitHub"
  },
  "footer": {
    "copyright": "¬© 2026 Prisma-SQL - Acelera lecturas de Prisma 2‚Äì7√ó (hasta 53.5√ó)",
    "tagline": "Haciendo Prisma a√∫n mejor"
  },
  "testingCallout": {
    "badge": "‚úì Validado",
    "title": "¬øC√≥mo aseguramos la correcci√≥n?",
    "description": "Cada consulta se valida contra Prisma con 137 pruebas end-to-end en PostgreSQL y SQLite",
    "link": "Ver metodolog√≠a de pruebas ‚Üí"
  },
  "testing": {
    "meta": {
      "title": "Metodolog√≠a de pruebas - Prisma-SQL",
      "description": "Enfoque de pruebas integral que valida con 137 pruebas E2E que el SQL generado coincide exactamente con la salida de Prisma",
      "keywords": "pruebas prisma, validaci√≥n sql, pruebas e2e, pruebas orm, pruebas de base de datos"
    },
    "hero": {
      "badge": "üß™ Aseguramiento de calidad",
      "title": "Pruebas",
      "titleHighlight": "Metodolog√≠a",
      "subtitle": "137 pruebas end-to-end validan que cada consulta SQL generada coincide exactamente con la salida de Prisma"
    },
    "stats": [
      {
        "value": "137",
        "label": "Pruebas E2E",
        "description": "Cada consulta validada"
      },
      {
        "value": "100%",
        "label": "Cobertura de paridad",
        "description": "Coincidencia byte a byte"
      },
      {
        "value": "2",
        "label": "Motores de base de datos",
        "description": "PostgreSQL y SQLite"
      },
      {
        "value": "3",
        "label": "Benchmarks de ORM",
        "description": "Prisma v6/v7, Drizzle"
      }
    ],
    "validation": {
      "title": "C√≥mo validamos la correcci√≥n",
      "subtitle": "Cada prueba sigue un proceso riguroso de 5 pasos para asegurar que el SQL generado produce resultados id√©nticos a Prisma",
      "steps": [
        {
          "title": "Generar SQL desde una consulta Prisma",
          "description": "Parsea los argumentos de la consulta Prisma y genera SQL equivalente usando los mismos modelos y esquema. El SQL generado usa consultas parametrizadas para seguridad y rendimiento."
        },
        {
          "title": "Ejecutar ambas consultas en paralelo",
          "description": "Ejecuta el SQL generado directamente con postgres.js o better-sqlite3, y ejecuta la misma consulta a trav√©s de Prisma. Ambas consultan el mismo estado de la base de datos."
        },
        {
          "title": "Normalizar resultados",
          "description": "Maneja diferencias de tipos (BigInt vs Number, precisi√≥n Decimal, serializaci√≥n de Date) y normaliza el orden de claves de objetos para una comparaci√≥n justa."
        },
        {
          "title": "Comprobaci√≥n de igualdad profunda",
          "description": "Verifica que los resultados coinciden exactamente: mismo n√∫mero de filas, mismos valores de campos, mismas relaciones anidadas, mismo orden. Cualquier diferencia falla la prueba."
        },
        {
          "title": "Benchmark de rendimiento",
          "description": "Mide el tiempo de ejecuci√≥n con 5 ejecuciones de calentamiento y luego promedia 10-50 iteraciones por prueba. Compara contra Prisma v6, Prisma v7 y Drizzle ORM."
        }
      ]
    },
    "advancedTechniques": {
      "title": "T√©cnicas avanzadas de validaci√≥n",
      "dataTypes": {
        "title": "Normalizaci√≥n de tipos de datos",
        "items": [
          {
            "label": "Conversi√≥n BigInt",
            "description": "BigInt de JavaScript ‚Üí Number para comparaci√≥n"
          },
          {
            "label": "Manejo de Decimal",
            "description": "Decimal de Prisma ‚Üí Float con precisi√≥n de 10 d√≠gitos"
          },
          {
            "label": "Normalizaci√≥n de fechas",
            "description": "Todos los valores DateTime ‚Üí null (enfoque en datos, no timestamps)"
          },
          {
            "label": "Parseo JSON",
            "description": "Detecci√≥n autom√°tica y parseo de strings JSON"
          },
          {
            "label": "Ordenaci√≥n de claves",
            "description": "Orden alfab√©tico para comparaci√≥n consistente"
          }
        ]
      },
      "performance": {
        "title": "Benchmarking de rendimiento",
        "items": [
          {
            "label": "Fase de calentamiento",
            "description": "5 iteraciones para preparar caches y JIT"
          },
          {
            "label": "Iteraciones adaptativas",
            "description": "5-50 ejecuciones seg√∫n complejidad de la consulta"
          },
          {
            "label": "Medici√≥n aislada",
            "description": "Cada tipo de consulta se mide de forma independiente"
          },
          {
            "label": "Comparaci√≥n multi-ORM",
            "description": "Prisma v6, v7, Drizzle, SQL generado"
          },
          {
            "label": "Tiempo de generaci√≥n de SQL",
            "description": "Medici√≥n separada de la sobrecarga de generaci√≥n de consultas"
          }
        ]
      }
    },
    "coverage": {
      "title": "Cobertura de pruebas integral",
      "subtitle": "Las pruebas cubren cada operaci√≥n de lectura de Prisma en m√∫ltiples niveles de complejidad",
      "categories": [
        {
          "title": "Operaciones de consulta",
          "items": [
            "findMany con filtros complejos",
            "findFirst con skip y paginaci√≥n",
            "findUnique por ID y campos √∫nicos",
            "count con condiciones WHERE",
            "aggregate (sum, avg, min, max)",
            "groupBy con cl√°usulas HAVING"
          ]
        },
        {
          "title": "Escenarios complejos",
          "items": [
            "Includes anidados (4 niveles de profundidad)",
            "Filtros de relaci√≥n (some/every/none)",
            "Distinct con funciones de ventana",
            "Paginaci√≥n con cursor",
            "Select + include combinados",
            "Conteos de relaci√≥n (_count)"
          ]
        },
        {
          "title": "Tipos de filtro",
          "items": [
            "Comparaci√≥n (lt/lte/gt/gte)",
            "L√≥gicos (AND/OR/NOT)",
            "Operaciones de string (contains/startsWith)",
            "Comprobaciones NULL (is/isNot)",
            "IN/NOT IN con arrays",
            "Modos de sensibilidad a may√∫sculas/min√∫sculas"
          ]
        }
      ]
    },
    "databaseSpecific": {
      "postgres": {
        "title": "Pruebas en PostgreSQL",
        "items": [
          "B√∫squedas case-insensitive con ILIKE",
          "Operaciones JSON/JSONB",
          "Manejo de campos array",
          "Soporte para tipos compuestos",
          "Validaci√≥n de funciones de ventana",
          "Pruebas de aislamiento de transacciones"
        ]
      },
      "sqlite": {
        "title": "Pruebas en SQLite",
        "items": [
          "Coincidencia de patrones LIKE",
          "Validaci√≥n de la extensi√≥n JSON1",
          "Emulaci√≥n de funciones de ventana",
          "Optimizaci√≥n DISTINCT",
          "Correlaci√≥n de subconsultas",
          "Manejo de afinidad de texto"
        ]
      }
    },
    "example": {
      "title": "Ejemplo de caso de prueba",
      "subtitle": "Mira c√≥mo validamos una consulta anidada compleja con filtros de relaci√≥n",
      "filename": "tests/e2e/postgres.test.ts",
      "code": "it('nested relation filter', () =>\n  runParityTest(\n    db,\n    benchmarkResults,\n    'findMany nested relation',\n    'Organization',\n    {\n      method: 'findMany',\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      }\n    },\n    () => db.prisma.organization.findMany({\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      },\n      orderBy: { id: 'asc' }\n    }),\n  )\n)\n\n// runParityTest internally:\n// 1. Calls generateSQL() with the args\n// 2. Executes generated SQL directly\n// 3. Executes Prisma query\n// 4. Normalizes both results\n// 5. Deep equality check - fails if any difference\n// 6. Benchmarks execution time"
    },
    "executionFlow": {
      "title": "Qu√© ocurre durante la ejecuci√≥n de las pruebas",
      "steps": [
        {
          "number": "1",
          "title": "Generaci√≥n de consulta (microsegundos)",
          "description": "La funci√≥n generateSQL() parsea los args de Prisma y crea SQL parametrizado. Este paso se mide por separado para medir la sobrecarga de generaci√≥n."
        },
        {
          "number": "2",
          "title": "Ejecuci√≥n paralela (milisegundos)",
          "description": "Ambas consultas alcanzan el mismo estado de base de datos simult√°neamente usando Promise.all(), garantizando comparaci√≥n justa y condiciones de datos id√©nticas."
        },
        {
          "number": "3",
          "title": "Normalizaci√≥n profunda",
          "description": "Los resultados pasan por normalizaci√≥n recursiva: BigInt‚ÜíNumber, Decimal‚ÜíFloat(10), Date‚Üínull, parseo JSON, ordenaci√≥n de claves. Esto asegura comparaci√≥n byte a byte."
        },
        {
          "number": "4",
          "title": "Igualdad estricta",
          "description": "Comparaci√≥n por JSON stringify con tolerancia cero. Cualquier diferencia en n√∫mero de filas, valores de campos, objetos anidados u orden falla la prueba con un diff detallado."
        },
        {
          "number": "5",
          "title": "Medici√≥n de rendimiento",
          "description": "Tras la validaci√≥n, 5-50 iteraciones miden el tiempo medio de ejecuci√≥n. Los resultados incluyen: Prisma v6, Prisma v7, Drizzle ORM, SQL generado y sobrecarga de generaci√≥n de SQL."
        }
      ]
    },
    "multiVersion": {
      "title": "Validaci√≥n multi-versi√≥n",
      "description": "Cada prueba se ejecuta contra Prisma v6 y v7 para asegurar compatibilidad entre versiones:",
      "v6": {
        "title": "Prisma v6 (6.16.3)",
        "items": [
          "Uso directo de PrismaClient",
          "Arquitectura legacy del engine",
          "M√©tricas base de rendimiento"
        ]
      },
      "v7": {
        "title": "Prisma v7 (7.2.0)",
        "items": [
          "Arquitectura basada en adapters",
          "@prisma/adapter-pg y adapter-better-sqlite3",
          "Nuevas optimizaciones del engine"
        ]
      }
    },
    "benchmarkReports": {
      "title": "Reportes autom√°ticos de benchmarks",
      "description": "Todos los resultados de benchmarks se generan autom√°ticamente y se guardan como archivos JSON para transparencia total:",
      "files": [
        "benchmark-results/v6-postgres-latest.json",
        "benchmark-results/v7-postgres-latest.json",
        "benchmark-results/v6-sqlite-latest.json",
        "benchmark-results/v7-sqlite-latest.json"
      ],
      "footer": "Cada archivo contiene: nombre de prueba, tiempo de ejecuci√≥n Prisma, tiempo de SQL generado, tiempo de Drizzle, ratios de aceleraci√≥n y timestamp ISO."
    },
    "cta": {
      "title": "Explora la suite completa de pruebas",
      "subtitle": "Las 137 pruebas son open source. Revisa el c√≥digo de pruebas, benchmarks y la l√≥gica de validaci√≥n.",
      "button1": "Ver suite de pruebas ‚Üí",
      "button2": "Ver benchmarks"
    }
  },
  "sqlPrevention": {
    "meta": {
      "title": "Prevenci√≥n de inyecci√≥n SQL - Seguridad Prisma-SQL",
      "description": "Metodolog√≠a de prevenci√≥n de inyecci√≥n SQL usando enlace de par√°metros, validaci√≥n basada en esquema y 137 pruebas enfocadas en seguridad (suite actual)",
      "keywords": "prevenci√≥n de inyecci√≥n sql, consultas parametrizadas, seguridad sql, seguridad de base de datos, seguridad prisma"
    },
    "hero": {
      "badge": "üîí Seguridad primero",
      "title": "Inyecci√≥n SQL",
      "titleHighlight": "Prevenci√≥n",
      "subtitle": "Los valores proporcionados por el usuario nunca se interpolan en el texto SQL ‚Äî los valores se enlazan mediante placeholders de par√°metros (dependiente del dialecto, p. ej. $1 o ?)"
    },
    "stats": [
      {
        "value": "100%",
        "label": "Enlace por par√°metros",
        "description": "Todos los valores del usuario usan placeholders"
      },
      {
        "value": "Cero",
        "label": "Interpolaci√≥n de valores",
        "description": "Los datos del usuario nunca aparecen en el texto SQL"
      },
      {
        "value": "Garantizado",
        "label": "Conservaci√≥n de orden",
        "description": "Los placeholders mapean a params 1:1"
      },
      {
        "value": "137",
        "label": "Pruebas de seguridad",
        "description": "Cobertura de intentos de inyecci√≥n (suite actual)"
      }
    ],
    "threat": {
      "title": "Entendiendo la inyecci√≥n SQL",
      "subtitle": "La inyecci√≥n SQL sigue siendo una de las vulnerabilidades m√°s cr√≠ticas en aplicaciones web",
      "description": "La inyecci√≥n SQL ocurre cuando datos no confiables se incorporan al texto SQL sin un enlace seguro por par√°metros. Los atacantes pueden manipular el significado de la consulta para acceder a datos no autorizados, modificar registros o provocar operaciones no deseadas.",
      "examples": {
        "title": "Patrones comunes de ataque",
        "items": [
          {
            "name": "Evasi√≥n de autenticaci√≥n",
            "attack": "admin' OR '1'='1",
            "description": "Intenta eludir el login haciendo que la condici√≥n WHERE siempre sea verdadera"
          },
          {
            "name": "Exfiltraci√≥n de datos",
            "attack": "' UNION SELECT password FROM users--",
            "description": "Usa UNION para intentar extraer datos de otras tablas"
          },
          {
            "name": "Comandos destructivos",
            "attack": "'; DROP TABLE users; --",
            "description": "Intenta a√±adir sentencias extra para borrar datos"
          },
          {
            "name": "Abuso de bug de orden de par√°metros",
            "attack": "Exploit: si placeholders y params no coinciden, los checks de autorizaci√≥n pueden usar valores incorrectos",
            "description": "Ejemplo: WHERE userId=$1 AND isAdmin=$2, pero params=[true, 123] en vez de [123, true] puede conceder acceso admin incorrectamente"
          }
        ]
      }
    },
    "protection": {
      "title": "Estrategia de protecci√≥n en m√∫ltiples capas",
      "subtitle": "Cada consulta pasa por m√∫ltiples capas de validaci√≥n de seguridad",
      "layers": [
        {
          "title": "Capa 1: Enlace autom√°tico de par√°metros",
          "description": "Todos los valores proporcionados por el usuario se convierten en par√°metros enlazados. Los valores no entran al texto SQL como literales.",
          "guarantees": [
            "Los valores del usuario se representan con placeholders espec√≠ficos del dialecto (p. ej. $1 o ?)",
            "Los arrays se parametrizan (placeholders expandidos o par√°metros array seg√∫n dialecto/estrategia)",
            "NULL y valores opcionales se manejan sin concatenar input del usuario al texto SQL",
            "Valores de fecha/hora se parametrizan",
            "Valores JSON se parametrizan"
          ]
        },
        {
          "title": "Capa 2: Validaci√≥n de nombres de campos",
          "description": "Cada nombre de campo se valida contra los metadatos del esquema de Prisma antes de generar la consulta.",
          "guarantees": [
            "Solo se permiten campos definidos en el esquema",
            "Filtros de relaci√≥n validados mediante metadatos del esquema",
            "No se aceptan nombres de campo arbitrarios",
            "Campos no soportados o computados se rechazan cuando corresponde",
            "Se rechazan payloads de prototype pollution (p. ej. __proto__, constructor)"
          ]
        },
        {
          "title": "Capa 3: Sanitizaci√≥n de identificadores",
          "description": "Nombres de tablas, columnas y aliases se validan y se citan/escapan de forma segura seg√∫n sea requerido.",
          "guarantees": [
            "Se rechazan caracteres de control",
            "Palabras reservadas se citan cuando es necesario",
            "Soporte para calificaci√≥n de esquema cuando est√° configurado",
            "Escape de comillas dobles (o equivalente del dialecto) para identificadores",
            "Se aplica longitud m√°xima de identificadores seg√∫n dialecto"
          ]
        },
        {
          "title": "Capa 4: Validaci√≥n de operadores",
          "description": "Solo se permiten operadores conocidos y seguros para cada tipo de campo.",
          "guarantees": [
            "Operadores string: contains, startsWith, endsWith",
            "Operadores num√©ricos: lt, lte, gt, gte",
            "Operadores de array: in, notIn con validaci√≥n de tipos",
            "Operadores l√≥gicos: AND, OR, NOT validados estructuralmente",
            "Operadores desconocidos se rechazan inmediatamente"
          ]
        },
        {
          "title": "Capa 5: Garant√≠a de orden de par√°metros",
          "description": "Un orden estricto asegura que cada placeholder mapea exactamente a un par√°metro en el orden de inserci√≥n, evitando desajustes.",
          "guarantees": [
            "Contador secuencial evita reordenamiento",
            "Construcci√≥n de SQL y del array de params en sincron√≠a",
            "Sin buffers intermedios ni reordenamientos",
            "Verificaci√≥n por tests: SQL generado y params siempre alinean",
            "Correspondencia 1 a 1: placeholder N ‚Üí params[N-1] (o mapeo equivalente seg√∫n dialecto)"
          ]
        }
      ]
    },
    "formalProofs": {
      "title": "Garant√≠as formales de seguridad",
      "subtitle": "Esbozos de prueba de resistencia a inyecci√≥n bajo supuestos de dise√±o (enlace de par√°metros, sin bypass de SQL crudo, uso correcto del driver)",
      "proofs": [
        {
          "title": "Teorema 1: Aislamiento de valores",
          "statement": "Para todo valor proporcionado por el usuario V, no existe ruta de ejecuci√≥n donde V aparezca como texto SQL en el string de consulta generado.",
          "proof": "Por construcci√≥n, todas las rutas que manejan valores del usuario llaman a addParameter(value) que:\n1. Almacena el valor en un array params separado\n2. Devuelve un token placeholder para el texto SQL\n3. Solo el token placeholder se agrega al string SQL\n4. El driver recibe el texto SQL y los valores de par√°metros por separado\n‚à¥ Los valores del usuario no se parsean como sintaxis SQL",
          "code": "const addParameter = (params: any[], value: any) => {\n  params.push(value)\n  const index = params.length\n  return `$${index}`\n}"
        },
        {
          "title": "Teorema 2: Clausura de nombres de campos",
          "statement": "El conjunto de nombres de campo F en cualquier consulta generada es un subconjunto de los campos definidos en el esquema S, es decir, F ‚äÜ S.",
          "proof": "Para cada referencia de campo:\n1. Se extrae el nombre del campo del objeto de consulta\n2. Se busca en metadatos del esquema\n3. Si el campo no existe, se lanza error\n4. Solo campos validados llegan a la generaci√≥n de SQL\n‚à¥ No pueden aparecer nombres de campos arbitrarios en SQL",
          "code": "const validateField = (field: string, model: Model) => {\n  if (!model.fields.has(field)) {\n    throw new Error(`Field ${field} does not exist`)\n  }\n  return model.fields.get(field)\n}"
        },
        {
          "title": "Teorema 3: Seguridad de operadores",
          "statement": "Para cualquier operador O aplicado al campo F, O es miembro de los operadores permitidos para el tipo T de F.",
          "proof": "Algoritmo de validaci√≥n de operadores:\n1. Extraer el tipo de campo T del esquema\n2. Definir allowed_ops(T) = { operadores v√°lidos para el tipo T }\n3. Para el operador O en la consulta:\n   - Si O ‚àâ allowed_ops(T), lanzar error\n   - Si no, aplicar el operador usando enlace de par√°metros\n‚à¥ Solo se usan operadores apropiados al tipo",
          "code": "const ALLOWED_OPS: Record<string, string[]> = {\n  String: ['contains', 'startsWith', 'endsWith'],\n  Int: ['lt', 'lte', 'gt', 'gte']\n}\nif (!ALLOWED_OPS[fieldType]?.includes(operator)) {\n  throw new Error('Invalid operator')\n}"
        },
        {
          "title": "Teorema 4: Seguridad de identificadores",
          "statement": "Todos los identificadores SQL I se validan para prevenir caracteres de control y asegurar un quoting/escaping seguro seg√∫n dialecto.",
          "proof": "Procesamiento de identificadores:\n1. Rechazar si contiene caracteres de control\n2. Escapar comillas internas seg√∫n reglas del dialecto\n3. Citar identificadores cuando es necesario (palabras reservadas o caracteres especiales)\n4. Aplicar l√≠mites de longitud por dialecto\n‚à¥ Los identificadores no pueden romper la sintaxis SQL ni introducir tokens inyectados",
          "code": "const quoteIdentifier = (id: string) => {\n  if (/[\\x00-\\x1F]/.test(id)) {\n    throw new Error('Invalid characters')\n  }\n  const escaped = id.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(id) || isReservedKeyword(id)\n  return needsQuoting ? `\"${escaped}\"` : id\n}"
        },
        {
          "title": "Teorema 5: Consistencia del orden de par√°metros",
          "statement": "Para cada posici√≥n de placeholder N emitida en el texto SQL, params[N-1] contiene el valor exacto destinado a esa posici√≥n, sin reordenamientos ni desajustes.",
          "proof": "Garant√≠a de orden de par√°metros:\n1. Un √∫nico tracker mantiene el orden de inserci√≥n\n2. Cada llamada add() agrega el valor a params y emite inmediatamente el siguiente placeholder\n3. La construcci√≥n del SQL y del array params avanza en sincron√≠a\n4. No hay reordenamientos intermedios\n‚à¥ Se mantiene correspondencia 1 a 1 durante todo el proceso",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}\n\nconst tracker = new ParameterTracker()\nconst sql = `WHERE email = ${tracker.add(email)} AND age > ${tracker.add(age)}`\nconst params = tracker.getParams()"
        }
      ]
    },
    "testCoverage": {
      "title": "Cobertura integral de pruebas de seguridad",
      "subtitle": "137 pruebas validan protecci√≥n contra vectores comunes de inyecci√≥n SQL y casos l√≠mite (suite actual)",
      "categories": [
        {
          "title": "Parametrizaci√≥n de valores (basic.test.ts)",
          "tests": [
            "Strings con comillas: user'with'quotes",
            "Strings con punto y coma: user;extra",
            "Keywords SQL como valores: DROP TABLE users",
            "Inyecci√≥n compleja: '; DROP TABLE users; --",
            "Ataques UNION: ' UNION SELECT * FROM users--",
            "Ataques booleanos: admin' OR '1'='1",
            "Inyecci√≥n de comentarios: test@example.com' -- comment"
          ]
        },
        {
          "title": "Validaci√≥n de nombres de campos (identifiers.test.ts)",
          "tests": [
            "Rechazar nombres de campo maliciosos en SELECT",
            "Rechazar nombres de campo maliciosos en WHERE",
            "Rechazar nombres de campo maliciosos en ORDER BY",
            "Rechazar inyecci√≥n SQL en nombres de campo",
            "Rechazar campos inexistentes",
            "Rechazar prototype pollution: __proto__, constructor"
          ]
        },
        {
          "title": "Seguridad de patrones LIKE (like-patterns.test.ts)",
          "tests": [
            "Inyecci√≥n de comod√≠n: %' OR '1'='1",
            "Inyecci√≥n con guion bajo: test_' OR '1'='1",
            "Manejo de backslash: test\\\\'; DROP--",
            "M√∫ltiples comodines: %_%'; DROP--",
            "Inyecci√≥n case-insensitive: '; UNION SELECT--"
          ]
        },
        {
          "title": "Seguridad de operadores de array (array-operators.test.ts)",
          "tests": [
            "IN con arrays maliciosos: ['; DROP--', 'UNION SELECT--']",
            "NOT IN con inyecci√≥n: ['; TRUNCATE--', 'DELETE FROM--']",
            "Manejo de array vac√≠o",
            "Validaci√≥n de arrays grandes (100+ items)",
            "Manejo de arrays con tipos mixtos"
          ]
        },
        {
          "title": "Casos l√≠mite (edge-cases.test.ts)",
          "tests": [
            "Inyecci√≥n Unicode: \\u0027 OR \\u00271\\u0027=\\u00271",
            "Inyecci√≥n codificada en hex: 0x31=0x31--",
            "URL encoded: %27%3B%20DROP%20TABLE",
            "Consultas apiladas: '; DROP TABLE users; SELECT",
            "Time-based blind (seg√∫n dialecto): WAITFOR DELAY '00:00:05'--",
            "Basada en UNION: UNION ALL SELECT null, password",
            "Intentos de inyecci√≥n de segundo orden"
          ]
        },
        {
          "title": "Verificaci√≥n de orden de par√°metros (basic.test.ts)",
          "tests": [
            "Posiciones de placeholders secuenciales",
            "El array de par√°metros coincide con el orden de placeholders",
            "Consultas complejas mantienen el orden a trav√©s de condiciones",
            "Condiciones OR/AND anidadas preservan la secuencia de par√°metros",
            "Filtros de relaci√≥n mantienen el mapeo correcto de par√°metros"
          ]
        }
      ]
    },
    "codeExamples": {
      "title": "Seguro vs. inseguro: comparaci√≥n de c√≥digo",
      "unsafe": {
        "title": "‚ùå Inseguro: concatenaci√≥n de strings",
        "code": "const email = req.body.email\nconst sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\""
      },
      "safe": {
        "title": "‚úÖ Seguro: enlace autom√°tico de par√°metros",
        "code": "const email = req.body.email\nconst { sql, params } = toSQL('User', 'findMany', {\n  where: { email }\n})\n\nconst result = { sql, params }"
      }
    },
    "implementation": {
      "title": "Detalles de implementaci√≥n",
      "sections": [
        {
          "title": "Gesti√≥n de par√°metros",
          "description": "Un tracking centralizado de par√°metros asegura que cada valor del usuario se enlace como par√°metro y mantenga orden estable",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}"
        },
        {
          "title": "Validaci√≥n de campos",
          "description": "La validaci√≥n basada en esquema previene acceso arbitrario a campos",
          "code": "function validateField(\n  fieldName: string,\n  model: ModelInfo\n): FieldInfo {\n  const field = model.fields.get(fieldName)\n  if (!field) {\n    throw new Error(\n      `Field \"${fieldName}\" does not exist`\n    )\n  }\n  return field\n}"
        },
        {
          "title": "Citado de identificadores",
          "description": "Validaci√≥n y quoting de identificadores consciente del dialecto previene inyecci√≥n basada en identificadores",
          "code": "function quoteIdentifier(identifier: string): string {\n  if (/[\\x00-\\x1F]/.test(identifier)) {\n    throw new Error('Invalid control characters')\n  }\n\n  const escaped = identifier.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(identifier) || isReservedKeyword(identifier)\n\n  if (needsQuoting) {\n    return `\"${escaped}\"`\n  }\n\n  return identifier\n}"
        }
      ]
    },
    "bestPractices": {
      "title": "Mejores pr√°cticas de seguridad",
      "practices": [
        {
          "title": "Nunca desactivar la validaci√≥n",
          "description": "No omitas la validaci√≥n del esquema ni las comprobaciones de campos. Son capas cr√≠ticas de seguridad.",
          "do": "Usa la librer√≠a tal como est√° dise√±ada con validaci√≥n completa",
          "dont": "Omitir validaci√≥n del esquema o inyectar SQL crudo en el texto de consulta"
        },
        {
          "title": "Mantener el esquema actualizado",
          "description": "Aseg√∫rate de que tu esquema Prisma refleje con precisi√≥n la estructura de tu base de datos.",
          "do": "Ejecuta prisma db pull y prisma generate tras cambios de esquema",
          "dont": "Usar DMMF o definiciones de esquema desactualizadas"
        },
        {
          "title": "Validar tipos de entrada",
          "description": "TypeScript aporta seguridad en compilaci√≥n, pero la validaci√≥n en runtime a√±ade defensa en profundidad.",
          "do": "Usa los tipos generados por Prisma para argumentos de consulta",
          "dont": "Convertir input del usuario a any antes de pasarlo a consultas"
        },
        {
          "title": "Monitorear patrones de consulta",
          "description": "Registra y monitorea SQL generado y par√°metros en producci√≥n para detectar anomal√≠as y mal uso.",
          "do": "Habilita logging de consultas y revisa patrones",
          "dont": "Ejecutar en producci√≥n sin monitoreo"
        }
      ]
    },
    "securityCallout": {
      "badge": "üîí Seguridad verificada",
      "title": "¬øC√≥mo prevenimos inyecci√≥n SQL?",
      "description": "Validaci√≥n multi-capa con enlace de par√°metros, chequeos de campos basados en esquema y 137 pruebas de seguridad (suite actual)",
      "link": "Ver detalles de seguridad ‚Üí"
    },
    "cta": {
      "title": "Seguridad por dise√±o",
      "subtitle": "La protecci√≥n contra inyecci√≥n SQL est√° integrada en cada capa de esta librer√≠a. Revisa las pruebas de seguridad y los detalles de implementaci√≥n directamente.",
      "button1": "Ver pruebas de seguridad ‚Üí",
      "button2": "Ver c√≥digo fuente"
    }
  }
}
