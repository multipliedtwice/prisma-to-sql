{
  "meta": {
    "title": "Fix Slow Prisma Queries: 2‚Äì7√ó Faster Reads (Up to 53.5√ó) | Prisma-SQL",
    "description": "Is Prisma slow? Speed up slow Prisma reads by 2‚Äì7√ó without refactors. Bypass Prisma‚Äôs read execution path with direct SQL execution in PostgreSQL and SQLite (up to 53.5√ó on SQLite relation filters). Production-ready optimization for read-heavy Prisma workloads.",
    "keywords": "slow prisma, prisma slow, prisma performance, fix slow prisma, speed up prisma, prisma optimization, prisma query speed, slow prisma queries, prisma performance issues, make prisma faster, postgresql, sqlite"
  },
  "header": {
    "cta": "Fix Slow Prisma ‚Üí"
  },
  "hero": {
    "badge": "üöÄ The Solution for Slow Prisma",
    "title": "Fix Slow Prisma Queries",
    "titleHighlight": "Make Your API 2‚Äì7√ó Faster (Up to 53.5√ó)",
    "description": "Is Prisma slow? You're not alone. Love Prisma's DX but need better performance?",
    "descriptionBold": "Speed up slow Prisma queries by 2‚Äì7√ó",
    "descriptionSuffix": "(up to 53.5√ó on SQLite relation filters) without changing any existing queries.",
    "cta1": "Speed Up Prisma Now",
    "cta2": "See How It Works",
    "trustBadges": [
      "Faster Prisma Reads",
      "No Query Changes",
      "Production-Ready",
      "137 E2E Tests"
    ],
    "codeTitle": "Fix slow Prisma in one line",
    "codeSnippet": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)\n\nconst users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
  },
  "stats": [
    {
      "value": "2‚Äì7√ó",
      "label": "Faster Prisma Reads",
      "subtitle": "Typical speedup",
      "color": "text-accent"
    },
    {
      "value": "0",
      "label": "Query Changes",
      "subtitle": "Keep your existing Prisma calls",
      "color": "text-blue-600"
    },
    {
      "value": "137",
      "label": "E2E Tests",
      "subtitle": "Verified solution",
      "color": "text-purple-600"
    },
    {
      "value": "100%",
      "label": "Type Safety",
      "subtitle": "Same Prisma API",
      "color": "text-pink-600"
    }
  ],
  "problem": {
    "title": "Why Is Prisma Slow?",
    "subtitle": "Understanding Prisma's evolution and performance characteristics helps explain why this extension exists.",
    "historyTitle": "The Prisma Journey: DX First, Performance Matters at Scale",
    "history": [
      {
        "period": "üéØ 2019: The Birth of Modern Prisma",
        "description": "Prisma 2 launched in 2019, changing the TypeScript ORM landscape with type-safe database access and generated types from your schema. Prisma introduced an engine-based architecture to translate queries, validate them, and provide strong guarantees that were hard to achieve with traditional JavaScript ORMs."
      },
      {
        "period": "‚ö° 2020‚Äì2022: Rapid Growth & Feature Expansion",
        "description": "Prisma added powerful features like nested writes, transactions, and middleware. The feature set expanded, but every query still paid an architectural cost: queries are represented, validated, executed, and results are shaped to match the Prisma API."
      },
      {
        "period": "üìä 2023: Overhead Becomes Noticeable at Scale",
        "description": "As more teams deployed Prisma in high-traffic workloads, the fixed per-query overhead became measurable. This is most visible on read-heavy endpoints, analytics, aggregations, and large result sets. The overhead is not a bug; it's the cost of Prisma‚Äôs guarantees and API behavior."
      },
      {
        "period": "üöÄ 2024‚Äì2025: Prisma Performance Work Continues",
        "description": "Prisma shipped major updates focused on performance and engine changes. Even with improvements, there is still an unavoidable cost to parsing, validating, planning, and shaping results compared to executing raw SQL directly."
      },
      {
        "period": "üéØ 2026: prisma-sql Extension Released",
        "description": "This extension focuses on read performance. It bypasses Prisma‚Äôs read execution path for findMany, findFirst, findUnique, count, aggregate, and groupBy, while keeping Prisma for writes, migrations, schema management, and type generation. Validate compatibility with your Prisma version before rollout."
      }
    ],
    "whyExists": {
      "title": "üí° Why This Extension Exists",
      "description": "Prisma made the right architectural choices for its goals: type safety, developer experience, and cross-database behavior. But those choices create overhead that's noticeable at scale. This extension doesn't replace Prisma‚Äîit optimizes reads for teams that want Prisma's DX plus faster execution where it matters."
    },
    "technical": [
      {
        "title": "Query Translation Layer",
        "description": "Prisma translates your query inputs into database-specific SQL. This enables cross-database behavior and Prisma's API semantics, but adds processing time before the database sees the SQL.",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Validation & Type Guarantees",
        "description": "Prisma validates queries against the schema and enforces API-level guarantees. These safeguards prevent classes of bugs, but they also add overhead to each query.",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Result Shaping",
        "description": "Results are shaped to match Prisma's API behavior. This is great for DX and consistency, but it adds latency, especially on large result sets and complex includes.",
        "iconPath": "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
      }
    ],
    "conclusion": "This extension complements Prisma by offering a faster path for read queries. You keep everything you love about Prisma while getting 2‚Äì7√ó faster reads in typical cases (and up to 53.5√ó in SQLite relation filters) when performance matters."
  },
  "performance": {
    "title": "How Much Faster? Real Benchmarks",
    "subtitle": "Comprehensive comparison across Prisma v6, v7, Drizzle ORM, and Prisma-SQL",
    "environment": "Benchmark environment: MacBook Pro M1 ‚Ä¢ PostgreSQL 15 ‚Ä¢ SQLite 3.43 ‚Ä¢ 137 test cases per database",
    "databases": [
      {
        "name": "PostgreSQL",
        "color": "accent",
        "subtitle": "Average across 57 test cases",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "2.10ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "1.95ms",
            "width": 93,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.08√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "1.40ms",
            "width": 67,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.50√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.90ms",
            "width": 43,
            "bgColor": "bg-gradient-to-r from-accent to-green-600",
            "color": "text-accent",
            "speedup": "2.34√ó"
          }
        ],
        "highlights": [
          {
            "label": "Distinct Queries",
            "value": "6.3√ó",
            "description": "vs Prisma v6"
          },
          {
            "label": "Relation Filters",
            "value": "5.5√ó",
            "description": "vs Prisma v6 (none)"
          }
        ]
      },
      {
        "name": "SQLite",
        "color": "purple",
        "subtitle": "Average across 56 test cases",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "5.48ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "4.12ms",
            "width": 75,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.33√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "2.11ms",
            "width": 39,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "2.60√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.73ms",
            "width": 13,
            "bgColor": "bg-gradient-to-r from-purple-500 to-pink-600",
            "color": "text-purple-600",
            "speedup": "7.50√ó"
          }
        ],
        "highlights": [
          {
            "label": "Simple Queries",
            "value": "12.6√ó",
            "description": "vs Prisma v6"
          },
          {
            "label": "Relation Filters",
            "value": "69.7√ó",
            "description": "vs Prisma v6 (none)"
          }
        ]
      }
    ],
    "footer": "Benchmarks based on 137 E2E tests per database. Prisma v6.16.3, Prisma v7.2.0, Drizzle ORM latest.",
    "footerLink": "View complete benchmark data"
  },
  "howItWorks": {
    "title": "How It Optimizes Prisma",
    "subtitle": "Bypass Prisma's read execution path while keeping Prisma's API and types",
    "steps": [
      {
        "title": "Intercept Prisma Queries",
        "description": "Extension catches read operations (findMany, findFirst, findUnique, count, aggregate, groupBy) before they execute"
      },
      {
        "title": "Generate Optimized SQL",
        "description": "Convert Prisma queries into fast, parameterized SQL with optimized JOINs"
      },
      {
        "title": "Execute Directly",
        "description": "Run queries through postgres.js or better-sqlite3, bypassing Prisma read overhead"
      },
      {
        "title": "Return Compatible Results",
        "description": "Results match Prisma's expected shape. Types, IntelliSense, and existing query code remain unchanged"
      }
    ],
    "codeExample": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})\n\n// Direct SQL execution for reads\n// Benchmarked around ~1.00ms on this workload\n// Same Prisma query code"
  },
  "features": {
    "title": "Why Choose This Prisma Extension?",
    "subtitle": "Get raw SQL execution speed for reads while keeping Prisma's developer experience",
    "items": [
      {
        "title": "Instant Prisma Speedup",
        "description": "One-time setup accelerates Prisma reads. No refactoring, no migration, no downtime.",
        "color": "accent",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Keep Your Prisma Types",
        "description": "Full TypeScript support maintained. Type inference, autocomplete, and compile-time safety preserved while accelerating reads.",
        "color": "blue",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Production-Tested Solution",
        "description": "137 E2E tests validate compatibility with recent Prisma versions. Used to accelerate Prisma reads in production apps.",
        "color": "purple",
        "iconPath": "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"
      },
      {
        "title": "Multiple Database Support",
        "description": "Optimize Prisma reads on PostgreSQL (including Neon, Supabase) and SQLite.",
        "color": "pink",
        "iconPath": "M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
      },
      {
        "title": "Pre-Compiled Option",
        "description": "Optional generator creates build-time SQL, reducing overhead to microseconds for your hottest queries.",
        "color": "yellow",
        "iconPath": "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
      },
      {
        "title": "Serverless Ready (Node Runtimes)",
        "description": "Works in serverless Node runtimes. Edge runtime support depends on runtime constraints and the driver you use.",
        "color": "green",
        "iconPath": "M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"
      }
    ]
  },
  "useCases": {
    "title": "When Prisma Performance Matters Most",
    "subtitle": "Common scenarios where this extension makes a real difference",
    "cases": [
      {
        "title": "üìä Analytics & Reporting",
        "description": "Prisma aggregations and groupBy operations benefit significantly from direct SQL execution",
        "color": "blue",
        "benefits": [
          "5√ó faster groupBy accelerates reports",
          "Faster aggregate queries",
          "Real-time metrics with lower latency"
        ]
      },
      {
        "title": "üöÄ High-Traffic APIs",
        "description": "Per-query overhead compounds under load, especially on read-heavy endpoints",
        "color": "purple",
        "benefits": [
          "Lower API response times",
          "Handle more requests per instance",
          "Reduce infrastructure costs"
        ]
      },
      {
        "title": "‚òÅÔ∏è Serverless Functions",
        "description": "Every millisecond matters in serverless: reduce read latency where it counts",
        "color": "green",
        "benefits": [
          "Better p95/p99 on reads",
          "Lower costs through faster reads",
          "Faster reads without refactors"
        ]
      },
      {
        "title": "üì± Mobile Backends",
        "description": "Users notice latency: faster reads improve perceived UX immediately",
        "color": "orange",
        "benefits": [
          "Faster feed loading",
          "Faster pagination",
          "More responsive interactions"
        ]
      }
    ]
  },
  "installation": {
    "title": "Optimize Prisma in 3 Steps",
    "subtitle": "Accelerate Prisma reads in under 60 seconds",
    "steps": [
      {
        "title": "Install the Prisma Extension",
        "language": "language-bash",
        "code": "# PostgreSQL\nnpm install prisma-sql postgres\n\n# SQLite\nnpm install prisma-sql better-sqlite3"
      },
      {
        "title": "Add Extension to Prisma Client",
        "language": "language-typescript",
        "code": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)"
      },
      {
        "title": "Use Prisma Normally",
        "language": "language-typescript",
        "code": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
      }
    ]
  },
  "faq": {
    "title": "Prisma Performance FAQ",
    "subtitle": "Common questions about optimizing Prisma reads",
    "questions": [
      {
        "question": "Why does Prisma have overhead?",
        "answer": "Prisma adds overhead because it implements API guarantees like schema-based validation, consistent query behavior, and result shaping. Those layers provide a great developer experience but cost time compared to executing raw SQL directly."
      },
      {
        "question": "How do I optimize Prisma queries?",
        "answer": "Optimize read-heavy Prisma workloads by adding this extension. It executes read operations via direct SQL using postgres.js or better-sqlite3 while keeping Prisma's API and types. Setup is a small initialization change and does not require refactoring your existing queries."
      },
      {
        "question": "Is Prisma slower than raw SQL?",
        "answer": "For many read workloads, yes. There is architectural overhead compared to raw SQL execution. This extension aims to keep Prisma's DX while reducing read latency by executing SQL directly."
      },
      {
        "question": "Can I speed up Prisma without changing existing queries?",
        "answer": "Yes. Add the extension once during Prisma Client initialization and keep your existing Prisma query code unchanged. Read operations run faster while your Prisma API, types, and schema remain the same."
      },
      {
        "question": "Does this work in production?",
        "answer": "Yes. It is validated with 137 E2E tests and designed to be used in production. Always verify compatibility with your Prisma version and run your own regression tests before rollout."
      },
      {
        "question": "What causes slower Prisma aggregations?",
        "answer": "Aggregations and groupBy often amplify fixed overhead (query processing and result shaping) and can involve larger intermediate result sets. This extension optimizes those reads by generating SQL directly, which typically reduces latency on aggregation-heavy endpoints."
      }
    ]
  },
  "cta": {
    "title": "Ready to Speed Up Prisma?",
    "subtitle": "Join developers optimizing Prisma reads: 2‚Äì7√ó faster (up to 53.5√ó)",
    "button1": "Install Prisma-SQL",
    "button2": "View on GitHub"
  },
  "footer": {
    "copyright": "¬© 2026 Prisma-SQL - Speed up Prisma reads by 2‚Äì7√ó (up to 53.5√ó)",
    "tagline": "Making Prisma even better"
  },
  "testingCallout": {
    "badge": "‚úì Validated",
    "title": "How do we ensure correctness?",
    "description": "Every query is validated against Prisma with 137 end-to-end tests across PostgreSQL and SQLite",
    "link": "View Testing Methodology ‚Üí"
  },
  "testing": {
    "meta": {
      "title": "Testing Methodology - Prisma-SQL",
      "description": "Comprehensive testing approach validating 137 E2E tests ensure generated SQL matches Prisma output exactly",
      "keywords": "prisma testing, sql validation, e2e tests, orm testing, database testing"
    },
    "hero": {
      "badge": "üß™ Quality Assurance",
      "title": "Testing",
      "titleHighlight": "Methodology",
      "subtitle": "137 end-to-end tests validate every generated SQL query matches Prisma's output exactly"
    },
    "stats": [
      {
        "value": "137",
        "label": "E2E Tests",
        "description": "Every query validated"
      },
      {
        "value": "100%",
        "label": "Parity Coverage",
        "description": "Byte-for-byte match"
      },
      {
        "value": "2",
        "label": "Database Engines",
        "description": "PostgreSQL & SQLite"
      },
      {
        "value": "3",
        "label": "ORM Benchmarks",
        "description": "Prisma v6/v7, Drizzle"
      }
    ],
    "validation": {
      "title": "How We Validate Correctness",
      "subtitle": "Every test follows a rigorous 5-step validation process to ensure generated SQL produces identical results to Prisma",
      "steps": [
        {
          "title": "Generate SQL from Prisma Query",
          "description": "Parse Prisma query arguments and generate equivalent SQL using the same models and schema. The generated SQL uses parameterized queries for security and performance."
        },
        {
          "title": "Execute Both Queries in Parallel",
          "description": "Run the generated SQL directly via postgres.js or better-sqlite3, and execute the same query through Prisma. Both hit the same database state."
        },
        {
          "title": "Normalize Results",
          "description": "Handle type differences (BigInt vs Number, Decimal precision, Date serialization) and normalize object key ordering for fair comparison."
        },
        {
          "title": "Deep Equality Check",
          "description": "Verify results match exactly: same number of rows, same field values, same nested relations, same ordering. Any mismatch fails the test."
        },
        {
          "title": "Benchmark Performance",
          "description": "Measure execution time with 5 warmup runs, then average 10-50 iterations per test. Compare against Prisma v6, Prisma v7, and Drizzle ORM."
        }
      ]
    },
    "advancedTechniques": {
      "title": "Advanced Validation Techniques",
      "dataTypes": {
        "title": "Data Type Normalization",
        "items": [
          {
            "label": "BigInt Conversion",
            "description": "JavaScript BigInt ‚Üí Number for comparison"
          },
          {
            "label": "Decimal Handling",
            "description": "Prisma Decimal ‚Üí Float with 10-digit precision"
          },
          {
            "label": "Date Normalization",
            "description": "All DateTime values ‚Üí null (focus on data, not timestamps)"
          },
          {
            "label": "JSON Parsing",
            "description": "Automatic detection and parsing of JSON strings"
          },
          {
            "label": "Object Key Sorting",
            "description": "Alphabetical ordering for consistent comparison"
          }
        ]
      },
      "performance": {
        "title": "Performance Benchmarking",
        "items": [
          {
            "label": "Warmup Phase",
            "description": "5 iterations to prime caches and JIT"
          },
          {
            "label": "Adaptive Iterations",
            "description": "5-50 runs based on query complexity"
          },
          {
            "label": "Isolated Measurement",
            "description": "Each query type measured independently"
          },
          {
            "label": "Multi-ORM Comparison",
            "description": "Prisma v6, v7, Drizzle, Generated SQL"
          },
          {
            "label": "SQL Generation Time",
            "description": "Separate timing for query generation overhead"
          }
        ]
      }
    },
    "coverage": {
      "title": "Comprehensive Test Coverage",
      "subtitle": "Tests cover every Prisma read operation across multiple complexity levels",
      "categories": [
        {
          "title": "Query Operations",
          "items": [
            "findMany with complex filters",
            "findFirst with skip & pagination",
            "findUnique by ID & unique fields",
            "count with WHERE conditions",
            "aggregate (sum, avg, min, max)",
            "groupBy with HAVING clauses"
          ]
        },
        {
          "title": "Complex Scenarios",
          "items": [
            "Nested includes (4 levels deep)",
            "Relation filters (some/every/none)",
            "Distinct with window functions",
            "Cursor pagination",
            "Select + include combined",
            "Relation counts (_count)"
          ]
        },
        {
          "title": "Filter Types",
          "items": [
            "Comparison (lt/lte/gt/gte)",
            "Logical (AND/OR/NOT)",
            "String ops (contains/startsWith)",
            "NULL checks (is/isNot)",
            "IN/NOT IN arrays",
            "Case sensitivity modes"
          ]
        }
      ]
    },
    "databaseSpecific": {
      "postgres": {
        "title": "PostgreSQL Testing",
        "items": [
          "ILIKE case-insensitive searches",
          "JSON/JSONB operations",
          "Array field handling",
          "Composite type support",
          "Window function validation",
          "Transaction isolation testing"
        ]
      },
      "sqlite": {
        "title": "SQLite Testing",
        "items": [
          "LIKE pattern matching",
          "JSON1 extension validation",
          "Window function emulation",
          "DISTINCT optimization",
          "Subquery correlation",
          "Text affinity handling"
        ]
      }
    },
    "example": {
      "title": "Example Test Case",
      "subtitle": "See how we validate a complex nested query with relation filters",
      "filename": "tests/e2e/postgres.test.ts",
      "code": "it('nested relation filter', () =>\n  runParityTest(\n    db,\n    benchmarkResults,\n    'findMany nested relation',\n    'Organization',\n    {\n      method: 'findMany',\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      }\n    },\n    () => db.prisma.organization.findMany({\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      },\n      orderBy: { id: 'asc' }\n    }),\n  )\n)\n\n// runParityTest internally:\n// 1. Calls generateSQL() with the args\n// 2. Executes generated SQL directly\n// 3. Executes Prisma query\n// 4. Normalizes both results\n// 5. Deep equality check - fails if any difference\n// 6. Benchmarks execution time"
    },
    "executionFlow": {
      "title": "What Happens During Test Execution",
      "steps": [
        {
          "number": "1",
          "title": "Query Generation (Microseconds)",
          "description": "The generateSQL() function parses Prisma args and creates parameterized SQL. This step is benchmarked separately to measure query generation overhead."
        },
        {
          "number": "2",
          "title": "Parallel Execution (Milliseconds)",
          "description": "Both queries hit the same database state simultaneously using Promise.all(), ensuring fair comparison and identical data conditions."
        },
        {
          "number": "3",
          "title": "Deep Normalization",
          "description": "Results undergo recursive normalization: BigInt‚ÜíNumber, Decimal‚ÜíFloat(10), Date‚Üínull, JSON parse, key sorting. This ensures byte-for-byte comparison accuracy."
        },
        {
          "number": "4",
          "title": "Strict Equality",
          "description": "JSON stringify comparison with zero tolerance. Any mismatch in row count, field values, nested objects, or ordering fails the test with detailed diff output."
        },
        {
          "number": "5",
          "title": "Performance Measurement",
          "description": "After validation, 5-50 iterations measure average execution time. Results include: Prisma v6, Prisma v7, Drizzle ORM, Generated SQL, and SQL generation overhead."
        }
      ]
    },
    "multiVersion": {
      "title": "Multi-Version Validation",
      "description": "Every test runs against both Prisma v6 and v7 to ensure compatibility across versions:",
      "v6": {
        "title": "Prisma v6 (6.16.3)",
        "items": [
          "Direct PrismaClient usage",
          "Legacy engine architecture",
          "Baseline performance metrics"
        ]
      },
      "v7": {
        "title": "Prisma v7 (7.2.0)",
        "items": [
          "Adapter-based architecture",
          "@prisma/adapter-pg & adapter-better-sqlite3",
          "New engine optimizations"
        ]
      }
    },
    "benchmarkReports": {
      "title": "Automated Benchmark Reports",
      "description": "All benchmark results are automatically generated and stored as JSON files for complete transparency:",
      "files": [
        "benchmark-results/v6-postgres-latest.json",
        "benchmark-results/v7-postgres-latest.json",
        "benchmark-results/v6-sqlite-latest.json",
        "benchmark-results/v7-sqlite-latest.json"
      ],
      "footer": "Each file contains: test name, Prisma execution time, generated SQL time, Drizzle time, speedup ratios, and ISO timestamp."
    },
    "cta": {
      "title": "Explore the Full Test Suite",
      "subtitle": "All 137 tests are open source. Review the test code, benchmarks, and validation logic.",
      "button1": "View Test Suite ‚Üí",
      "button2": "See Benchmarks"
    }
  },
  "sqlPrevention": {
    "meta": {
      "title": "SQL Injection Prevention - Prisma-SQL Security",
      "description": "SQL injection prevention methodology using parameter binding, schema-based validation, and 137 security-focused tests (current suite)",
      "keywords": "sql injection prevention, parameterized queries, sql security, database security, prisma security"
    },
    "hero": {
      "badge": "üîí Security First",
      "title": "SQL Injection",
      "titleHighlight": "Prevention",
      "subtitle": "User-provided values are never interpolated into SQL text ‚Äî values are bound via parameter placeholders (dialect-specific, e.g. $1 or ?)"
    },
    "stats": [
      {
        "value": "100%",
        "label": "Parameter Bound",
        "description": "All user-provided values use placeholders"
      },
      {
        "value": "Zero",
        "label": "Value Interpolation",
        "description": "User data never appears in SQL text"
      },
      {
        "value": "Guaranteed",
        "label": "Order Preservation",
        "description": "Placeholders map to params 1:1"
      },
      {
        "value": "137",
        "label": "Security Tests",
        "description": "Injection attempt coverage (current suite)"
      }
    ],
    "threat": {
      "title": "Understanding SQL Injection",
      "subtitle": "SQL injection remains one of the most critical web application vulnerabilities",
      "description": "SQL injection occurs when untrusted data is incorporated into SQL text without safe parameter binding. Attackers can manipulate query meaning to access unauthorized data, modify records, or trigger unintended operations.",
      "examples": {
        "title": "Common Attack Patterns",
        "items": [
          {
            "name": "Authentication Bypass",
            "attack": "admin' OR '1'='1",
            "description": "Attempts to bypass login by making the WHERE condition always true"
          },
          {
            "name": "Data Exfiltration",
            "attack": "' UNION SELECT password FROM users--",
            "description": "Uses UNION to attempt extracting data from other tables"
          },
          {
            "name": "Destructive Commands",
            "attack": "'; DROP TABLE users; --",
            "description": "Attempts to append extra statements to delete data"
          },
          {
            "name": "Parameter Order Bug Abuse",
            "attack": "Exploit: If placeholders and params are mismatched, authorization checks may use the wrong values",
            "description": "Example: WHERE userId=$1 AND isAdmin=$2, but params=[true, 123] instead of [123, true] can incorrectly grant admin access"
          }
        ]
      }
    },
    "protection": {
      "title": "Multi-Layer Protection Strategy",
      "subtitle": "Every query passes through multiple security validation layers",
      "layers": [
        {
          "title": "Layer 1: Automatic Parameter Binding",
          "description": "All user-provided values are converted into bound parameters. Values do not enter SQL text as literals.",
          "guarantees": [
            "User values are represented using dialect-specific placeholders (e.g. $1 or ?)",
            "Array inputs are parameterized (expanded placeholders or array parameters depending on dialect/strategy)",
            "NULL and optional values handled without concatenating user input into SQL text",
            "Date/time values are parameterized",
            "JSON values are parameterized"
          ]
        },
        {
          "title": "Layer 2: Field Name Validation",
          "description": "Every field name is validated against the Prisma schema metadata before query generation.",
          "guarantees": [
            "Only schema-defined fields are allowed",
            "Relation filters validated via schema metadata",
            "No arbitrary field names accepted",
            "Unsupported/computed fields rejected where applicable",
            "Prototype pollution payloads are rejected (e.g. __proto__, constructor)"
          ]
        },
        {
          "title": "Layer 3: Identifier Sanitization",
          "description": "Table names, column names, and aliases are validated and safely quoted/escaped as required.",
          "guarantees": [
            "Control characters rejected",
            "Reserved keywords are quoted when needed",
            "Schema qualification supported where configured",
            "Double-quote escaping (or dialect equivalent) for identifiers",
            "Maximum identifier length enforced per dialect"
          ]
        },
        {
          "title": "Layer 4: Operator Validation",
          "description": "Only known, safe operators are allowed for each field type.",
          "guarantees": [
            "String operators: contains, startsWith, endsWith",
            "Numeric operators: lt, lte, gt, gte",
            "Array operators: in, notIn with type validation",
            "Logical operators: AND, OR, NOT validated structurally",
            "Unknown operators rejected immediately"
          ]
        },
        {
          "title": "Layer 5: Parameter Order Guarantee",
          "description": "Strict ordering ensures each placeholder maps to exactly one parameter in insertion order, preventing mismatches.",
          "guarantees": [
            "Sequential counter prevents reordering",
            "Lockstep SQL building and param array construction",
            "No intermediate buffer or reordering operations",
            "Test verification: generated SQL and params always align",
            "One-to-one correspondence: placeholder N ‚Üí params[N-1] (or equivalent mapping for the dialect)"
          ]
        }
      ]
    },
    "formalProofs": {
      "title": "Formal Security Guarantees",
      "subtitle": "Proof sketches for injection resistance under stated design assumptions (parameter binding, no raw-SQL bypass, correct driver usage)",
      "proofs": [
        {
          "title": "Theorem 1: Value Isolation",
          "statement": "For all user-provided values V, there exists no execution path where V appears as SQL text in the generated query string.",
          "proof": "By construction, all code paths that handle user values call addParameter(value) which:\n1. Stores the value in a separate params array\n2. Returns a placeholder token for the SQL text\n3. Only the placeholder token is appended into the SQL string\n4. The database driver receives SQL text and parameter values separately\n‚à¥ User values are not parsed as SQL syntax",
          "code": "const addParameter = (params: any[], value: any) => {\n  params.push(value)\n  const index = params.length\n  return `$${index}`\n}"
        },
        {
          "title": "Theorem 2: Field Name Closure",
          "statement": "The set of field names F in any generated query is a subset of schema-defined fields S, i.e., F ‚äÜ S.",
          "proof": "For every field reference:\n1. Field name extracted from query object\n2. Lookup performed against schema metadata\n3. If the field does not exist in the schema, an error is thrown\n4. Only validated fields reach SQL generation\n‚à¥ Arbitrary field names cannot appear in SQL",
          "code": "const validateField = (field: string, model: Model) => {\n  if (!model.fields.has(field)) {\n    throw new Error(`Field ${field} does not exist`)\n  }\n  return model.fields.get(field)\n}"
        },
        {
          "title": "Theorem 3: Operator Safety",
          "statement": "For any operator O applied to field F, O is a member of the allowed operators for F's type T.",
          "proof": "Operator validation algorithm:\n1. Extract field type T from schema\n2. Define allowed_ops(T) = { valid operators for type T }\n3. For operator O in query:\n   - If O ‚àâ allowed_ops(T), throw error\n   - Else apply operator using parameter binding\n‚à¥ Only type-appropriate operators can be used",
          "code": "const ALLOWED_OPS: Record<string, string[]> = {\n  String: ['contains', 'startsWith', 'endsWith'],\n  Int: ['lt', 'lte', 'gt', 'gte']\n}\nif (!ALLOWED_OPS[fieldType]?.includes(operator)) {\n  throw new Error('Invalid operator')\n}"
        },
        {
          "title": "Theorem 4: Identifier Safety",
          "statement": "All SQL identifiers I are validated to prevent control characters and to ensure safe quoting/escaping per dialect.",
          "proof": "Identifier processing:\n1. Reject if contains control characters\n2. Escape internal quote characters per dialect rules\n3. Quote identifiers when required (reserved keywords or special characters)\n4. Enforce per-dialect identifier length limits\n‚à¥ Identifiers cannot break SQL syntax or introduce injected tokens",
          "code": "const quoteIdentifier = (id: string) => {\n  if (/[\\x00-\\x1F]/.test(id)) {\n    throw new Error('Invalid characters')\n  }\n  const escaped = id.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(id) || isReservedKeyword(id)\n  return needsQuoting ? `\"${escaped}\"` : id\n}"
        },
        {
          "title": "Theorem 5: Parameter Order Consistency",
          "statement": "For every placeholder position N emitted into the SQL text, params[N-1] contains the exact value intended for that position, with no reordering or mismatch.",
          "proof": "Parameter ordering guarantee:\n1. A single tracker maintains insertion order\n2. Each add() call appends the value to params and immediately emits the next placeholder token\n3. SQL text construction and params construction proceed in lockstep\n4. No intermediate reordering operations occur\n‚à¥ One-to-one correspondence is maintained throughout",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}\n\nconst tracker = new ParameterTracker()\nconst sql = `WHERE email = ${tracker.add(email)} AND age > ${tracker.add(age)}`\nconst params = tracker.getParams()"
        }
      ]
    },
    "testCoverage": {
      "title": "Comprehensive Security Test Coverage",
      "subtitle": "137 tests validate protection against common SQL injection vectors and edge cases (current suite)",
      "categories": [
        {
          "title": "Value Parameterization (basic.test.ts)",
          "tests": [
            "Strings with quotes: user'with'quotes",
            "Strings with semicolons: user;extra",
            "SQL keywords as values: DROP TABLE users",
            "Complex injection: '; DROP TABLE users; --",
            "Union attacks: ' UNION SELECT * FROM users--",
            "Boolean attacks: admin' OR '1'='1",
            "Comment injection: test@example.com' -- comment"
          ]
        },
        {
          "title": "Field Name Validation (identifiers.test.ts)",
          "tests": [
            "Reject malicious field names in SELECT",
            "Reject malicious field names in WHERE",
            "Reject malicious field names in ORDER BY",
            "Reject SQL injection in field names",
            "Reject non-existent fields",
            "Reject prototype pollution: __proto__, constructor"
          ]
        },
        {
          "title": "LIKE Pattern Safety (like-patterns.test.ts)",
          "tests": [
            "Wildcard injection: %' OR '1'='1",
            "Underscore injection: test_' OR '1'='1",
            "Backslash handling: test\\\\'; DROP--",
            "Multiple wildcards: %_%'; DROP--",
            "Case insensitive injection: '; UNION SELECT--"
          ]
        },
        {
          "title": "Array Operator Safety (array-operators.test.ts)",
          "tests": [
            "IN with malicious arrays: ['; DROP--', 'UNION SELECT--']",
            "NOT IN with injection: ['; TRUNCATE--', 'DELETE FROM--']",
            "Empty array handling",
            "Large array validation (100+ items)",
            "Mixed type array handling"
          ]
        },
        {
          "title": "Edge Cases (edge-cases.test.ts)",
          "tests": [
            "Unicode injection: \\u0027 OR \\u00271\\u0027=\\u00271",
            "Hex-encoded injection: 0x31=0x31--",
            "URL encoded: %27%3B%20DROP%20TABLE",
            "Stacked queries: '; DROP TABLE users; SELECT",
            "Time-based blind (dialect-specific): WAITFOR DELAY '00:00:05'--",
            "UNION-based: UNION ALL SELECT null, password",
            "Second-order injection attempts"
          ]
        },
        {
          "title": "Parameter Order Verification (basic.test.ts)",
          "tests": [
            "Sequential placeholder positions",
            "Parameter array matches placeholder order",
            "Complex queries maintain order across conditions",
            "Nested OR/AND conditions preserve parameter sequence",
            "Relation filters maintain correct parameter mapping"
          ]
        }
      ]
    },
    "codeExamples": {
      "title": "Safe vs. Unsafe: Code Comparison",
      "unsafe": {
        "title": "‚ùå Unsafe: String Concatenation",
        "code": "const email = req.body.email\nconst sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\""
      },
      "safe": {
        "title": "‚úÖ Safe: Automatic Parameter Binding",
        "code": "const email = req.body.email\nconst { sql, params } = toSQL('User', 'findMany', {\n  where: { email }\n})\n\nconst result = { sql, params }"
      }
    },
    "implementation": {
      "title": "Implementation Details",
      "sections": [
        {
          "title": "Parameter Management",
          "description": "Centralized parameter tracking ensures every user-provided value is parameter bound and order-stable",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}"
        },
        {
          "title": "Field Validation",
          "description": "Schema-based validation prevents arbitrary field access",
          "code": "function validateField(\n  fieldName: string,\n  model: ModelInfo\n): FieldInfo {\n  const field = model.fields.get(fieldName)\n  if (!field) {\n    throw new Error(\n      `Field \"${fieldName}\" does not exist`\n    )\n  }\n  return field\n}"
        },
        {
          "title": "Identifier Quoting",
          "description": "Dialect-aware identifier validation and quoting prevents identifier-based syntax injection",
          "code": "function quoteIdentifier(identifier: string): string {\n  if (/[\\x00-\\x1F]/.test(identifier)) {\n    throw new Error('Invalid control characters')\n  }\n\n  const escaped = identifier.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(identifier) || isReservedKeyword(identifier)\n\n  if (needsQuoting) {\n    return `\"${escaped}\"`\n  }\n\n  return identifier\n}"
        }
      ]
    },
    "bestPractices": {
      "title": "Security Best Practices",
      "practices": [
        {
          "title": "Never Disable Validation",
          "description": "Do not bypass schema validation or field checking. These are critical security layers.",
          "do": "Use the library as designed with full validation",
          "dont": "Bypass schema validation or inject raw SQL into query text"
        },
        {
          "title": "Keep Schema Updated",
          "description": "Ensure your Prisma schema accurately reflects your database structure.",
          "do": "Run prisma db pull and prisma generate after schema changes",
          "dont": "Use outdated DMMF or schema definitions"
        },
        {
          "title": "Validate Input Types",
          "description": "TypeScript provides compile-time safety, but runtime validation adds defense in depth.",
          "do": "Use Prisma's generated types for query arguments",
          "dont": "Cast user input to any before passing to queries"
        },
        {
          "title": "Monitor Query Patterns",
          "description": "Log and monitor generated SQL and parameters in production to detect anomalies and misuse.",
          "do": "Enable query logging and review patterns",
          "dont": "Run in production without monitoring"
        }
      ]
    },
    "securityCallout": {
      "badge": "üîí Verified Secure",
      "title": "How do we prevent SQL injection?",
      "description": "Multi-layer validation with parameter binding, schema-based field checks, and 137 security tests (current suite)",
      "link": "View Security Details ‚Üí"
    },
    "cta": {
      "title": "Security Through Design",
      "subtitle": "SQL injection protection is built into every layer of this library. Review the security tests and implementation details directly.",
      "button1": "View Security Tests ‚Üí",
      "button2": "View Source Code"
    }
  }
}
