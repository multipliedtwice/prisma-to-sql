{
  "meta": {
    "title": "‡¶ß‡ßÄ‡¶∞ Prisma ‡¶ï‡ßÅ‡¶Ø‡¶º‡ßá‡¶∞‡¶ø ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®: 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶∞‡¶ø‡¶° (‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó) | Prisma-SQL",
    "description": "Prisma ‡¶ï‡¶ø ‡¶ß‡ßÄ‡¶∞? refactor ‡¶õ‡¶æ‡ßú‡¶æ‡¶á ‡¶ß‡ßÄ‡¶∞ Prisma reads 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ PostgreSQL ‡¶ì SQLite-‡¶è direct SQL execution ‡¶¶‡¶ø‡ßü‡ßá Prisma-‡¶è‡¶∞ read execution path bypass ‡¶ï‡¶∞‡ßÅ‡¶® (SQLite relation filters-‡¶è ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó)‡•§ read-heavy Prisma workloads-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø production-ready optimization‡•§",
    "keywords": "slow prisma, prisma slow, prisma performance, fix slow prisma, speed up prisma, prisma optimization, prisma query speed, slow prisma queries, prisma performance issues, make prisma faster, postgresql, sqlite"
  },
  "header": { "cta": "‡¶ß‡ßÄ‡¶∞ Prisma ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶® ‚Üí" },
  "hero": {
    "badge": "üöÄ ‡¶ß‡ßÄ‡¶∞ Prisma-‡¶è‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®",
    "title": "‡¶ß‡ßÄ‡¶∞ Prisma ‡¶ï‡ßÅ‡¶Ø‡¶º‡ßá‡¶∞‡¶ø ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®",
    "titleHighlight": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ API 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® (‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó)",
    "description": "Prisma ‡¶ï‡¶ø ‡¶ß‡ßÄ‡¶∞? ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶æ ‡¶®‡¶®‡•§ Prisma-‡¶è‡¶∞ DX ‡¶≠‡¶æ‡¶≤‡ßã ‡¶≤‡¶æ‡¶ó‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶Ü‡¶∞‡¶ì performance ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞?",
    "descriptionBold": "‡¶ß‡ßÄ‡¶∞ Prisma ‡¶ï‡ßÅ‡¶Ø‡¶º‡ßá‡¶∞‡¶ø 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®",
    "descriptionSuffix": "(SQLite relation filters-‡¶è ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó) ‡¶ï‡ßã‡¶®‡ßã existing query ‡¶®‡¶æ ‡¶¨‡¶¶‡¶≤‡ßá‡¶á‡•§",
    "cta1": "‡¶è‡¶ñ‡¶®‡¶á Prisma ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®",
    "cta2": "‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®",
    "trustBadges": [
      "‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ Prisma reads",
      "‡¶ï‡ßã‡¶®‡ßã query ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßü",
      "Production-ready",
      "137 E2E tests"
    ],
    "codeTitle": "‡¶è‡¶ï ‡¶≤‡¶æ‡¶á‡¶®‡ßá ‡¶ß‡ßÄ‡¶∞ Prisma ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®",
    "codeSnippet": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)\n\nconst users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
  },
  "stats": [
    {
      "value": "2‚Äì7√ó",
      "label": "‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ Prisma reads",
      "subtitle": "Typical speedup",
      "color": "text-accent"
    },
    {
      "value": "0",
      "label": "Query ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®",
      "subtitle": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ existing Prisma calls ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®",
      "color": "text-blue-600"
    },
    {
      "value": "137",
      "label": "E2E tests",
      "subtitle": "Verified solution",
      "color": "text-purple-600"
    },
    {
      "value": "100%",
      "label": "Type safety",
      "subtitle": "‡¶è‡¶ï‡¶á Prisma API",
      "color": "text-pink-600"
    }
  ],
  "problem": {
    "title": "Prisma ‡¶ï‡ßá‡¶® ‡¶ß‡ßÄ‡¶∞?",
    "subtitle": "Prisma-‡¶è‡¶∞ evolution ‡¶ì performance characteristics ‡¶¨‡ßÅ‡¶ù‡¶≤‡ßá ‡¶¨‡ßã‡¶ù‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶è‡¶á extension ‡¶ï‡ßá‡¶® ‡¶Ü‡¶õ‡ßá‡•§",
    "historyTitle": "Prisma-‡¶è‡¶∞ ‡¶Ø‡¶æ‡¶§‡ßç‡¶∞‡¶æ: ‡¶Ü‡¶ó‡ßá DX, ‡¶∏‡ßç‡¶ï‡ßá‡¶≤‡ßá performance ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£",
    "history": [
      {
        "period": "üéØ 2019: ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï Prisma-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Æ",
        "description": "Prisma 2 2019 ‡¶∏‡¶æ‡¶≤‡ßá ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡ßü, schema ‡¶•‡ßá‡¶ï‡ßá generated types ‡¶è‡¶¨‡¶Ç type-safe database access ‡¶¶‡¶ø‡ßü‡ßá TypeScript ORM landscape ‡¶¨‡¶¶‡¶≤‡ßá ‡¶¶‡ßá‡ßü‡•§ Prisma ‡¶è‡¶ï‡¶ü‡¶ø engine-based architecture ‡¶è‡¶®‡ßá‡¶õ‡ßá ‡¶Ø‡¶æ query translate, validate ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç ‡¶è‡¶Æ‡¶® ‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ guarantees ‡¶¶‡ßá‡ßü ‡¶Ø‡¶æ traditional JavaScript ORM-‡¶è ‡¶ï‡¶†‡¶ø‡¶® ‡¶õ‡¶ø‡¶≤‡•§"
      },
      {
        "period": "‚ö° 2020‚Äì2022: ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶¨‡ßÉ‡¶¶‡ßç‡¶ß‡¶ø ‡¶ì ‡¶´‡¶ø‡¶ö‡¶æ‡¶∞ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞",
        "description": "Prisma nested writes, transactions, middleware ‡¶Æ‡¶§‡ßã ‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ ‡¶´‡¶ø‡¶ö‡¶æ‡¶∞ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá‡•§ ‡¶´‡¶ø‡¶ö‡¶æ‡¶∞ ‡¶¨‡ßá‡¶°‡¶º‡ßá‡¶õ‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø query ‡¶è‡¶ñ‡¶®‡¶ì architectural cost ‡¶¶‡ßá‡ßü: query represent, validate, execute ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç Prisma API ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ result shape ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§"
      },
      {
        "period": "üìä 2023: ‡¶∏‡ßç‡¶ï‡ßá‡¶≤‡ßá overhead ‡¶ö‡ßã‡¶ñ‡ßá ‡¶™‡¶°‡¶º‡ßá",
        "description": "‡¶Ø‡¶ñ‡¶® ‡¶¨‡ßá‡¶∂‡¶ø ‡¶ü‡¶ø‡¶Æ high-traffic workloads-‡¶è Prisma deploy ‡¶ï‡¶∞‡ßá, per-query fixed overhead measurable ‡¶π‡ßü‡•§ ‡¶è‡¶ü‡¶ø read-heavy endpoints, analytics, aggregations, ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶°‡¶º result sets-‡¶è ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶¨‡ßá‡¶∂‡¶ø ‡¶¶‡ßá‡¶ñ‡¶æ ‡¶Ø‡¶æ‡ßü‡•§ ‡¶è‡¶ü‡¶ø bug ‡¶®‡ßü; Prisma-‡¶è‡¶∞ guarantees ‡¶ì API behavior-‡¶è‡¶∞ cost‡•§"
      },
      {
        "period": "üöÄ 2024‚Äì2025: Prisma performance ‡¶ï‡¶æ‡¶ú ‡¶ö‡¶≤‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡ßá",
        "description": "Prisma performance ‡¶ì engine changes-‡¶è ‡¶´‡ßã‡¶ï‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶¨‡ßú ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶¶‡ßá‡ßü‡•§ ‡¶â‡¶®‡ßç‡¶®‡¶§‡¶ø ‡¶∏‡¶§‡ßç‡¶§‡ßç‡¶¨‡ßá‡¶ì raw SQL ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø execute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡ßü parsing, validating, planning, ‡¶è‡¶¨‡¶Ç result shaping-‡¶è‡¶∞ unavoidable cost ‡¶•‡¶æ‡¶ï‡ßá‡•§"
      },
      {
        "period": "üéØ 2026: prisma-sql Extension ‡¶∞‡¶ø‡¶≤‡¶ø‡¶ú",
        "description": "‡¶è‡¶á extension read performance-‡¶è ‡¶´‡ßã‡¶ï‡¶æ‡¶∏ ‡¶ï‡¶∞‡ßá‡•§ findMany, findFirst, findUnique, count, aggregate, groupBy-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Prisma read execution path bypass ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ writes, migrations, schema management, ‡¶è‡¶¨‡¶Ç type generation-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Prisma ‡¶∞‡ßá‡¶ñ‡ßá ‡¶¶‡ßá‡ßü‡•§ rollout-‡¶è‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Prisma version-‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá compatibility validate ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
      }
    ],
    "whyExists": {
      "title": "üí° ‡¶è‡¶á extension ‡¶ï‡ßá‡¶® ‡¶Ü‡¶õ‡ßá",
      "description": "Prisma ‡¶§‡¶æ‡¶∞ ‡¶≤‡¶ï‡ßç‡¶∑‡ßç‡¶Ø ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶∏‡¶†‡¶ø‡¶ï architectural choices ‡¶®‡¶ø‡ßü‡ßá‡¶õ‡ßá: type safety, developer experience, ‡¶è‡¶¨‡¶Ç cross-database behavior‡•§ ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶è‡¶á choices ‡¶∏‡ßç‡¶ï‡ßá‡¶≤‡ßá noticeable overhead ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶á extension Prisma replace ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ‚Äî‡¶Ø‡ßá ‡¶ü‡¶ø‡¶Æ Prisma-‡¶è‡¶∞ DX ‡¶ö‡¶æ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ execution ‡¶ö‡¶æ‡¶® ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø reads optimize ‡¶ï‡¶∞‡ßá‡•§"
    },
    "technical": [
      {
        "title": "Query translation layer",
        "description": "Prisma ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ query inputs ‡¶ï‡ßá database-specific SQL-‡¶è translate ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶ü‡¶ø cross-database behavior ‡¶ì Prisma API semantics ‡¶¶‡ßá‡ßü, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ database SQL ‡¶¶‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá processing time ‡¶¨‡¶æ‡ßú‡¶æ‡ßü‡•§",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Validation ‡¶ì type guarantees",
        "description": "Prisma schema-‡¶è‡¶∞ ‡¶¨‡¶ø‡¶∞‡ßÅ‡¶¶‡ßç‡¶ß‡ßá queries validate ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç API-level guarantees enforce ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶á safeguards bug-‡¶è‡¶∞ ‡¶ï‡¶ø‡¶õ‡ßÅ class ‡¶∞‡ßã‡¶ß ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø query-‡¶§‡ßá overhead ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá‡•§",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Result shaping",
        "description": "Results Prisma API behavior ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ shape ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§ DX ‡¶ì consistency-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶≠‡¶æ‡¶≤‡ßã, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ latency ‡¶¨‡¶æ‡ßú‡¶æ‡ßü‚Äî‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶ï‡¶∞‡ßá ‡¶¨‡¶°‡¶º result sets ‡¶ì complex includes-‡¶è‡•§",
        "iconPath": "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
      }
    ],
    "conclusion": "‡¶è‡¶á extension Prisma-‡¶ï‡ßá complement ‡¶ï‡¶∞‡ßá read queries-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶™‡¶• ‡¶¶‡¶ø‡ßü‡ßá‡•§ ‡¶Ü‡¶™‡¶®‡¶ø Prisma-‡¶è‡¶∞ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡ßá‡¶∞ ‡¶∏‡¶¨‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∞‡¶æ‡¶ñ‡ßá‡¶®, ‡¶Ü‡¶∞ performance ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶≤‡ßá typical cases-‡¶è 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ reads (‡¶è‡¶¨‡¶Ç SQLite relation filters-‡¶è ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó) ‡¶™‡¶æ‡¶®‡•§"
  },
  "performance": {
    "title": "‡¶ï‡¶§‡¶ü‡¶æ ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§? ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶¨‡ßá‡¶û‡ßç‡¶ö‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï",
    "subtitle": "Prisma v6, v7, Drizzle ORM ‡¶è‡¶¨‡¶Ç Prisma-SQL ‡¶ú‡ßÅ‡¶°‡¶º‡ßá ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡ßÉ‡¶§ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ",
    "environment": "‡¶¨‡ßá‡¶û‡ßç‡¶ö‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï ‡¶™‡¶∞‡¶ø‡¶¨‡ßá‡¶∂: MacBook Pro M1 ‚Ä¢ PostgreSQL 15 ‚Ä¢ SQLite 3.43 ‚Ä¢ ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏‡ßá 137‡¶ü‡¶ø ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡ßá‡¶∏",
    "databases": [
      {
        "name": "PostgreSQL",
        "color": "accent",
        "subtitle": "57‡¶ü‡¶ø ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡ßá‡¶∏‡ßá‡¶∞ ‡¶ó‡¶°‡¶º",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "2.10ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "1.95ms",
            "width": 93,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.08√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "1.40ms",
            "width": 67,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.50√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.90ms",
            "width": 43,
            "bgColor": "bg-gradient-to-r from-accent to-green-600",
            "color": "text-accent",
            "speedup": "2.34√ó"
          }
        ],
        "highlights": [
          {
            "label": "DISTINCT ‡¶ï‡ßÅ‡¶Ø‡¶º‡ßá‡¶∞‡¶ø",
            "value": "6.3√ó",
            "description": "Prisma v6 ‡¶è‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶Ø‡¶º"
          },
          {
            "label": "‡¶∞‡¶ø‡¶≤‡ßá‡¶∂‡¶® ‡¶´‡¶ø‡¶≤‡ßç‡¶ü‡¶æ‡¶∞",
            "value": "5.5√ó",
            "description": "Prisma v6 ‡¶è‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶Ø‡¶º (\"none\"-‡¶´‡¶ø‡¶≤‡ßç‡¶ü‡¶æ‡¶∞)"
          }
        ]
      },
      {
        "name": "SQLite",
        "color": "purple",
        "subtitle": "56‡¶ü‡¶ø ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡ßá‡¶∏‡ßá‡¶∞ ‡¶ó‡¶°‡¶º",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "5.48ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "4.12ms",
            "width": 75,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.33√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "2.11ms",
            "width": 39,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "2.60√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.73ms",
            "width": 13,
            "bgColor": "bg-gradient-to-r from-purple-500 to-pink-600",
            "color": "text-purple-600",
            "speedup": "7.50√ó"
          }
        ],
        "highlights": [
          {
            "label": "‡¶∏‡¶π‡¶ú ‡¶ï‡ßÅ‡¶Ø‡¶º‡ßá‡¶∞‡¶ø",
            "value": "12.6√ó",
            "description": "Prisma v6 ‡¶è‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶Ø‡¶º"
          },
          {
            "label": "‡¶∞‡¶ø‡¶≤‡ßá‡¶∂‡¶® ‡¶´‡¶ø‡¶≤‡ßç‡¶ü‡¶æ‡¶∞",
            "value": "69.7√ó",
            "description": "Prisma v6 ‡¶è‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶Ø‡¶º (\"none\"-‡¶´‡¶ø‡¶≤‡ßç‡¶ü‡¶æ‡¶∞)"
          }
        ]
      }
    ],
    "footer": "‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏‡ßá 137‡¶ü‡¶ø E2E ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡ßá‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø ‡¶ï‡¶∞‡ßá ‡¶¨‡ßá‡¶û‡ßç‡¶ö‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï‡•§ Prisma v6.16.3, Prisma v7.2.0, Drizzle ORM latest.",
    "footerLink": "‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡ßá‡¶û‡ßç‡¶ö‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï ‡¶°‡ßá‡¶ü‡¶æ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®"
  },
  "howItWorks": {
    "title": "‡¶è‡¶ü‡¶ø Prisma ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá optimize ‡¶ï‡¶∞‡ßá",
    "subtitle": "Prisma-‡¶è‡¶∞ API ‡¶ì types ‡¶∞‡ßá‡¶ñ‡ßá Prisma read execution path bypass ‡¶ï‡¶∞‡ßÅ‡¶®",
    "steps": [
      {
        "title": "Prisma queries intercept ‡¶ï‡¶∞‡ßÅ‡¶®",
        "description": "Extension read operations (findMany, findFirst, findUnique, count, aggregate, groupBy) execute ‡¶π‡¶ì‡ßü‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶ß‡¶∞‡ßá"
      },
      {
        "title": "Optimized SQL generate ‡¶ï‡¶∞‡ßÅ‡¶®",
        "description": "Prisma queries-‡¶ï‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§, parameterized SQL-‡¶è convert ‡¶ï‡¶∞‡ßÅ‡¶® optimized JOINs ‡¶∏‡¶π"
      },
      {
        "title": "Direct execute ‡¶ï‡¶∞‡ßÅ‡¶®",
        "description": "postgres.js ‡¶¨‡¶æ better-sqlite3 ‡¶¶‡¶ø‡ßü‡ßá queries ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®, Prisma read overhead bypass ‡¶ï‡¶∞‡ßá"
      },
      {
        "title": "Compatible results ‡¶´‡ßá‡¶∞‡¶§ ‡¶¶‡¶ø‡¶®",
        "description": "Results Prisma-‡¶è‡¶∞ expected shape ‡¶Æ‡ßá‡¶≤‡ßá‡•§ Types, IntelliSense, ‡¶è‡¶¨‡¶Ç existing query code unchanged ‡¶•‡¶æ‡¶ï‡ßá"
      }
    ],
    "codeExample": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})\n\n// Direct SQL execution for reads\n// Benchmarked around ~1.00ms on this workload\n// Same Prisma query code"
  },
  "features": {
    "title": "‡¶ï‡ßá‡¶® ‡¶è‡¶á Prisma extension ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡ßá‡¶¨‡ßá‡¶®?",
    "subtitle": "Reads-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø raw SQL execution speed ‡¶™‡¶æ‡¶®, ‡¶∏‡¶æ‡¶•‡ßá Prisma-‡¶è‡¶∞ developer experience ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®",
    "items": [
      {
        "title": "‡¶á‡¶®‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶ü Prisma speedup",
        "description": "One-time setup Prisma reads accelerate ‡¶ï‡¶∞‡ßá‡•§ ‡¶ï‡ßã‡¶®‡ßã refactoring ‡¶®‡ßü, ‡¶ï‡ßã‡¶®‡ßã migration ‡¶®‡ßü, ‡¶ï‡ßã‡¶®‡ßã downtime ‡¶®‡ßü‡•§",
        "color": "accent",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Prisma types ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®",
        "description": "‡¶™‡ßÇ‡¶∞‡ßç‡¶£ TypeScript support ‡¶¨‡¶ú‡¶æ‡ßü ‡¶•‡¶æ‡¶ï‡ßá‡•§ Type inference, autocomplete, ‡¶è‡¶¨‡¶Ç compile-time safety ‡¶∞‡ßá‡¶ñ‡ßá reads ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶π‡ßü‡•§",
        "color": "blue",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Production-tested solution",
        "description": "137 E2E tests ‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï Prisma versions-‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá compatibility validate ‡¶ï‡¶∞‡ßá‡•§ Production apps-‡¶è Prisma reads ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§‡•§",
        "color": "purple",
        "iconPath": "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"
      },
      {
        "title": "Multiple database support",
        "description": "PostgreSQL (Neon, Supabase ‡¶∏‡¶π) ‡¶è‡¶¨‡¶Ç SQLite-‡¶è Prisma reads optimize ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
        "color": "pink",
        "iconPath": "M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
      },
      {
        "title": "Pre-compiled option",
        "description": "Optional generator build-time SQL ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá, ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ hottest queries-‡¶è‡¶∞ overhead microseconds-‡¶è ‡¶®‡¶æ‡¶Æ‡¶æ‡ßü‡•§",
        "color": "yellow",
        "iconPath": "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
      },
      {
        "title": "Serverless ready (Node runtimes)",
        "description": "Serverless Node runtimes-‡¶è ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§ Edge runtime support runtime constraints ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡ßá driver ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶® ‡¶§‡¶æ‡¶∞ ‡¶ì‡¶™‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞ ‡¶ï‡¶∞‡ßá‡•§",
        "color": "green",
        "iconPath": "M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"
      }
    ]
  },
  "useCases": {
    "title": "‡¶Ø‡¶ñ‡¶® Prisma performance ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£",
    "subtitle": "‡¶Ø‡ßá ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶™‡¶∞‡¶ø‡¶∏‡ßç‡¶•‡¶ø‡¶§‡¶ø‡¶§‡ßá ‡¶è‡¶á extension ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶Ü‡¶®‡ßá",
    "cases": [
      {
        "title": "üìä Analytics & reporting",
        "description": "Prisma aggregations ‡¶è‡¶¨‡¶Ç groupBy operations direct SQL execution ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßú ‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ ‡¶™‡¶æ‡ßü",
        "color": "blue",
        "benefits": [
          "5√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ groupBy ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßá",
          "‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ aggregate queries",
          "‡¶ï‡¶Æ latency-‡¶§‡ßá real-time metrics"
        ]
      },
      {
        "title": "üöÄ High-traffic APIs",
        "description": "Load-‡¶è‡¶∞ ‡¶Ö‡¶ß‡ßÄ‡¶®‡ßá per-query overhead ‡¶ú‡¶Æ‡ßá, ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶ï‡¶∞‡ßá read-heavy endpoints-‡¶è",
        "color": "purple",
        "benefits": [
          "‡¶ï‡¶Æ API response time",
          "‡¶™‡ßç‡¶∞‡¶§‡¶ø instance-‡¶è ‡¶¨‡ßá‡¶∂‡¶ø request handle",
          "‡¶á‡¶®‡¶´‡ßç‡¶∞‡¶æ ‡¶ñ‡¶∞‡¶ö ‡¶ï‡¶Æ‡¶æ‡¶®‡ßã"
        ]
      },
      {
        "title": "‚òÅÔ∏è Serverless functions",
        "description": "Serverless-‡¶è ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø millisecond ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£: ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡ßá read latency ‡¶ï‡¶Æ‡¶æ‡¶®",
        "color": "green",
        "benefits": [
          "Reads-‡¶è ‡¶≠‡¶æ‡¶≤‡ßã p95/p99",
          "‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ reads ‡¶¶‡¶ø‡ßü‡ßá ‡¶ï‡¶Æ ‡¶ñ‡¶∞‡¶ö",
          "Refactor ‡¶õ‡¶æ‡ßú‡¶æ‡¶á ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ reads"
        ]
      },
      {
        "title": "üì± Mobile backends",
        "description": "Users latency ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá: ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ reads perceived UX ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶ï‡¶∞‡ßá",
        "color": "orange",
        "benefits": [
          "‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ feed loading",
          "‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ pagination",
          "‡¶Ü‡¶∞‡¶ì responsive interactions"
        ]
      }
    ]
  },
  "installation": {
    "title": "3 ‡¶ß‡¶æ‡¶™‡ßá Prisma optimize ‡¶ï‡¶∞‡ßÅ‡¶®",
    "subtitle": "60 ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá Prisma reads accelerate ‡¶ï‡¶∞‡ßÅ‡¶®",
    "steps": [
      {
        "title": "Prisma extension ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®",
        "language": "language-bash",
        "code": "# PostgreSQL\nnpm install prisma-sql postgres\n\n# SQLite\nnpm install prisma-sql better-sqlite3"
      },
      {
        "title": "Prisma Client-‡¶è extension ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®",
        "language": "language-typescript",
        "code": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)"
      },
      {
        "title": "Prisma ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶≠‡¶æ‡¶¨‡ßá‡¶á ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®",
        "language": "language-typescript",
        "code": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
      }
    ]
  },
  "faq": {
    "title": "Prisma performance FAQ",
    "subtitle": "Prisma reads optimize ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®",
    "questions": [
      {
        "question": "Prisma-‡¶§‡ßá overhead ‡¶ï‡ßá‡¶®?",
        "answer": "Prisma schema-based validation, consistent query behavior, ‡¶è‡¶¨‡¶Ç result shaping ‡¶Æ‡¶§‡ßã API guarantees ‡¶¶‡ßá‡ßü ‡¶¨‡¶≤‡ßá overhead ‡¶Ø‡ßã‡¶ó ‡¶π‡ßü‡•§ ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã developer experience ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ raw SQL ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø execute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡ßü ‡¶∏‡¶Æ‡ßü ‡¶≤‡¶æ‡¶ó‡ßá‡•§"
      },
      {
        "question": "‡¶Ü‡¶Æ‡¶ø Prisma queries ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá optimize ‡¶ï‡¶∞‡¶¨?",
        "answer": "‡¶è‡¶á extension ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá read-heavy Prisma workloads optimize ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶è‡¶ü‡¶ø postgres.js ‡¶¨‡¶æ better-sqlite3 ‡¶¶‡¶ø‡ßü‡ßá direct SQL-‡¶è reads execute ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Prisma-‡¶è‡¶∞ API ‡¶ì types ‡¶∞‡¶æ‡¶ñ‡ßá‡•§ Setup ‡¶π‡¶≤‡ßã ‡¶õ‡ßã‡¶ü initialization change‚Äîexisting queries refactor ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡ßü ‡¶®‡¶æ‡•§"
      },
      {
        "question": "Prisma ‡¶ï‡¶ø raw SQL-‡¶è‡¶∞ ‡¶ö‡ßá‡ßü‡ßá ‡¶ß‡ßÄ‡¶∞?",
        "answer": "‡¶Ö‡¶®‡ßá‡¶ï read workload-‡¶è‡¶∞ ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞‡ßá, ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å‡•§ raw SQL execution-‡¶è‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡ßü architectural overhead ‡¶•‡¶æ‡¶ï‡ßá‡•§ ‡¶è‡¶á extension Prisma-‡¶è‡¶∞ DX ‡¶∞‡ßá‡¶ñ‡ßá SQL ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø execute ‡¶ï‡¶∞‡ßá read latency ‡¶ï‡¶Æ‡¶æ‡¶§‡ßá ‡¶ö‡¶æ‡ßü‡•§"
      },
      {
        "question": "Existing queries ‡¶®‡¶æ ‡¶¨‡¶¶‡¶≤‡ßá‡¶á ‡¶ï‡¶ø Prisma ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü?",
        "answer": "‡¶π‡ßç‡¶Ø‡¶æ‡¶Å‡•§ Prisma Client initialization-‡¶è‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ extension ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶¨‡¶Ç existing Prisma query code unchanged ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®‡•§ Reads ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ö‡¶≤‡¶¨‡ßá, Prisma API, types, schema ‡¶è‡¶ï‡¶á ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§"
      },
      {
        "question": "‡¶è‡¶ü‡¶æ ‡¶ï‡¶ø production-‡¶è ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?",
        "answer": "‡¶π‡ßç‡¶Ø‡¶æ‡¶Å‡•§ 137 E2E tests ‡¶¶‡¶ø‡ßü‡ßá validate ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç production ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶® ‡¶ï‡¶∞‡¶æ‡•§ rollout-‡¶è‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Prisma version-‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá compatibility ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶®‡¶ø‡¶ú‡ßá‡¶∞ regression tests ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡•§"
      },
      {
        "question": "Prisma aggregations ‡¶ß‡ßÄ‡¶∞ ‡¶π‡ßü ‡¶ï‡ßá‡¶®?",
        "answer": "Aggregations ‡¶è‡¶¨‡¶Ç groupBy fixed overhead (query processing ‡¶ì result shaping) ‡¶¨‡¶æ‡ßú‡¶ø‡ßü‡ßá ‡¶¶‡ßá‡ßü ‡¶è‡¶¨‡¶Ç ‡¶¨‡ßú intermediate result sets ‡¶≤‡¶æ‡¶ó‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§ ‡¶è‡¶á extension SQL ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø generate ‡¶ï‡¶∞‡ßá reads optimize ‡¶ï‡¶∞‡ßá, ‡¶´‡¶≤‡ßá aggregation-heavy endpoints-‡¶è latency ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ ‡¶ï‡¶Æ‡ßá‡•§"
      }
    ]
  },
  "cta": {
    "title": "Prisma ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§?",
    "subtitle": "Prisma reads optimize ‡¶ï‡¶∞‡¶æ ‡¶°‡ßá‡¶≠‡ßá‡¶≤‡¶™‡¶æ‡¶∞‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó ‡¶¶‡¶ø‡¶®: 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ (‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó)",
    "button1": "Prisma-SQL ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®",
    "button2": "GitHub-‡¶è ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®"
  },
  "footer": {
    "copyright": "¬© 2026 Prisma-SQL - Prisma reads 2‚Äì7√ó ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® (‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö 53.5√ó)",
    "tagline": "Prisma-‡¶ï‡ßá ‡¶Ü‡¶∞‡¶ì ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ï‡¶∞‡¶õ‡¶ø"
  },
  "testingCallout": {
    "badge": "‚úì Validated",
    "title": "‡¶Ü‡¶Æ‡¶∞‡¶æ correctness ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶ø?",
    "description": "PostgreSQL ‡¶ì SQLite ‡¶ú‡ßÅ‡¶°‡¶º‡ßá 137 end-to-end tests ‡¶¶‡¶ø‡ßü‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø query Prisma-‡¶è‡¶∞ ‡¶¨‡¶ø‡¶∞‡ßÅ‡¶¶‡ßç‡¶ß‡ßá validate ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü",
    "link": "Testing Methodology ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® ‚Üí"
  },
  "testing": {
    "meta": {
      "title": "Testing Methodology - Prisma-SQL",
      "description": "Comprehensive testing approach validating 137 E2E tests ensure generated SQL matches Prisma output exactly",
      "keywords": "prisma testing, sql validation, e2e tests, orm testing, database testing"
    },
    "hero": {
      "badge": "üß™ Quality assurance",
      "title": "Testing",
      "titleHighlight": "Methodology",
      "subtitle": "137 end-to-end tests validate every generated SQL query matches Prisma's output exactly"
    },
    "stats": [
      {
        "value": "137",
        "label": "E2E tests",
        "description": "Every query validated"
      },
      {
        "value": "100%",
        "label": "Parity coverage",
        "description": "Byte-for-byte match"
      },
      {
        "value": "2",
        "label": "Database engines",
        "description": "PostgreSQL & SQLite"
      },
      {
        "value": "3",
        "label": "ORM benchmarks",
        "description": "Prisma v6/v7, Drizzle"
      }
    ],
    "validation": {
      "title": "‡¶Ü‡¶Æ‡¶∞‡¶æ correctness ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá validate ‡¶ï‡¶∞‡¶ø",
      "subtitle": "Generated SQL ‡¶Ø‡ßá‡¶® Prisma-‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã‡¶á ‡¶´‡¶≤ ‡¶¶‡ßá‡¶Ø‡¶º‚Äî‡¶è‡¶ü‡¶æ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø test ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡¶†‡ßã‡¶∞ 5-step process ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá",
      "steps": [
        {
          "title": "Prisma query ‡¶•‡ßá‡¶ï‡ßá SQL generate ‡¶ï‡¶∞‡ßÅ‡¶®",
          "description": "Prisma query arguments parse ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶á models ‡¶ì schema ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá equivalent SQL generate ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ Generated SQL security ‡¶ì performance-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø parameterized queries ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡•§"
        },
        {
          "title": "‡¶¶‡ßÅ‡¶ü‡¶ø query parallel-‡¶è execute ‡¶ï‡¶∞‡ßÅ‡¶®",
          "description": "postgres.js ‡¶¨‡¶æ better-sqlite3 ‡¶¶‡¶ø‡ßü‡ßá generated SQL direct ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®, ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶á query Prisma ‡¶¶‡¶ø‡ßü‡ßá ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡•§ ‡¶¶‡ßÅ‡¶ü‡ßã‡¶á ‡¶è‡¶ï‡¶á database state hit ‡¶ï‡¶∞‡ßá‡•§"
        },
        {
          "title": "Results normalize ‡¶ï‡¶∞‡ßÅ‡¶®",
          "description": "Type differences (BigInt vs Number, Decimal precision, Date serialization) handle ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶¨‡¶Ç fair comparison-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø object key ordering normalize ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
        },
        {
          "title": "Deep equality check",
          "description": "Results ‡¶è‡¶ï‡¶¶‡¶Æ ‡¶è‡¶ï‡¶á ‡¶ï‡¶ø‡¶®‡¶æ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡ßÅ‡¶®: row count, field values, nested relations, ordering‡•§ mismatch ‡¶π‡¶≤‡ßá test fail‡•§"
        },
        {
          "title": "Performance benchmark",
          "description": "5 warmup runs, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶™‡ßç‡¶∞‡¶§‡¶ø test-‡¶è 10‚Äì50 iterations average ‡¶ï‡¶∞‡ßá execution time ‡¶Æ‡¶æ‡¶™‡ßÅ‡¶®‡•§ Prisma v6, Prisma v7, ‡¶è‡¶¨‡¶Ç Drizzle ORM-‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá compare ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
        }
      ]
    },
    "advancedTechniques": {
      "title": "Advanced validation techniques",
      "dataTypes": {
        "title": "Data type normalization",
        "items": [
          {
            "label": "BigInt conversion",
            "description": "JavaScript BigInt ‚Üí Number for comparison"
          },
          {
            "label": "Decimal handling",
            "description": "Prisma Decimal ‚Üí Float with 10-digit precision"
          },
          {
            "label": "Date normalization",
            "description": "All DateTime values ‚Üí null (focus on data, not timestamps)"
          },
          {
            "label": "JSON parsing",
            "description": "Automatic detection and parsing of JSON strings"
          },
          {
            "label": "Object key sorting",
            "description": "Alphabetical ordering for consistent comparison"
          }
        ]
      },
      "performance": {
        "title": "Performance benchmarking",
        "items": [
          {
            "label": "Warmup phase",
            "description": "5 iterations to prime caches and JIT"
          },
          {
            "label": "Adaptive iterations",
            "description": "5-50 runs based on query complexity"
          },
          {
            "label": "Isolated measurement",
            "description": "Each query type measured independently"
          },
          {
            "label": "Multi-ORM comparison",
            "description": "Prisma v6, v7, Drizzle, Generated SQL"
          },
          {
            "label": "SQL generation time",
            "description": "Separate timing for query generation overhead"
          }
        ]
      }
    },
    "coverage": {
      "title": "Comprehensive test coverage",
      "subtitle": "Tests cover every Prisma read operation across multiple complexity levels",
      "categories": [
        {
          "title": "Query operations",
          "items": [
            "findMany with complex filters",
            "findFirst with skip & pagination",
            "findUnique by ID & unique fields",
            "count with WHERE conditions",
            "aggregate (sum, avg, min, max)",
            "groupBy with HAVING clauses"
          ]
        },
        {
          "title": "Complex scenarios",
          "items": [
            "Nested includes (4 levels deep)",
            "Relation filters (some/every/none)",
            "Distinct with window functions",
            "Cursor pagination",
            "Select + include combined",
            "Relation counts (_count)"
          ]
        },
        {
          "title": "Filter types",
          "items": [
            "Comparison (lt/lte/gt/gte)",
            "Logical (AND/OR/NOT)",
            "String ops (contains/startsWith)",
            "NULL checks (is/isNot)",
            "IN/NOT IN arrays",
            "Case sensitivity modes"
          ]
        }
      ]
    },
    "databaseSpecific": {
      "postgres": {
        "title": "PostgreSQL testing",
        "items": [
          "ILIKE case-insensitive searches",
          "JSON/JSONB operations",
          "Array field handling",
          "Composite type support",
          "Window function validation",
          "Transaction isolation testing"
        ]
      },
      "sqlite": {
        "title": "SQLite testing",
        "items": [
          "LIKE pattern matching",
          "JSON1 extension validation",
          "Window function emulation",
          "DISTINCT optimization",
          "Subquery correlation",
          "Text affinity handling"
        ]
      }
    },
    "example": {
      "title": "Example test case",
      "subtitle": "Relation filters ‡¶∏‡¶π ‡¶è‡¶ï‡¶ü‡¶ø complex nested query ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá validate ‡¶ï‡¶∞‡¶ø ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®",
      "filename": "tests/e2e/postgres.test.ts",
      "code": "it('nested relation filter', () =>\n  runParityTest(\n    db,\n    benchmarkResults,\n    'findMany nested relation',\n    'Organization',\n    {\n      method: 'findMany',\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      }\n    },\n    () => db.prisma.organization.findMany({\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      },\n      orderBy: { id: 'asc' }\n    }),\n  )\n)\n\n// runParityTest internally:\n// 1. Calls generateSQL() with the args\n// 2. Executes generated SQL directly\n// 3. Executes Prisma query\n// 4. Normalizes both results\n// 5. Deep equality check - fails if any difference\n// 6. Benchmarks execution time"
    },
    "executionFlow": {
      "title": "Test execution ‡¶ö‡¶≤‡¶æ‡¶ï‡¶æ‡¶≤‡ßá ‡¶ï‡ßÄ ‡¶ò‡¶ü‡ßá",
      "steps": [
        {
          "number": "1",
          "title": "Query generation (Microseconds)",
          "description": "generateSQL() Prisma args parse ‡¶ï‡¶∞‡ßá parameterized SQL ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶á step ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ‡¶≠‡¶æ‡¶¨‡ßá benchmark ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü query generation overhead ‡¶Æ‡¶æ‡¶™‡¶§‡ßá‡•§"
        },
        {
          "number": "2",
          "title": "Parallel execution (Milliseconds)",
          "description": "Promise.all() ‡¶¶‡¶ø‡ßü‡ßá ‡¶¶‡ßÅ‡¶ü‡ßã query ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ï‡¶á database state hit ‡¶ï‡¶∞‡ßá‚Äîfair comparison ‡¶ì identical data conditions ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßá‡•§"
        },
        {
          "number": "3",
          "title": "Deep normalization",
          "description": "Results recursive normalization ‡¶™‡¶æ‡ßü: BigInt‚ÜíNumber, Decimal‚ÜíFloat(10), Date‚Üínull, JSON parse, key sorting‡•§ ‡¶è‡¶§‡ßá byte-for-byte comparison accuracy ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶π‡ßü‡•§"
        },
        {
          "number": "4",
          "title": "Strict equality",
          "description": "Zero tolerance ‡¶∏‡¶π JSON stringify comparison‡•§ row count, field values, nested objects ‡¶¨‡¶æ ordering-‡¶è ‡¶ï‡ßã‡¶®‡ßã mismatch ‡¶π‡¶≤‡ßá detailed diff output ‡¶∏‡¶π fail‡•§"
        },
        {
          "number": "5",
          "title": "Performance measurement",
          "description": "Validation-‡¶è‡¶∞ ‡¶™‡¶∞‡ßá, 5‚Äì50 iterations average execution time ‡¶Æ‡¶æ‡¶™‡ßá‡•§ ‡¶´‡¶≤‡¶æ‡¶´‡¶≤: Prisma v6, Prisma v7, Drizzle ORM, Generated SQL, ‡¶è‡¶¨‡¶Ç SQL generation overhead‡•§"
        }
      ]
    },
    "multiVersion": {
      "title": "Multi-version validation",
      "description": "Compatibility ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø test Prisma v6 ‡¶ì v7 ‡¶¶‡ßÅ‡¶ü‡ßã‡¶∞ ‡¶¨‡¶ø‡¶∞‡ßÅ‡¶¶‡ßç‡¶ß‡ßá‡¶á ‡¶ö‡¶≤‡ßá:",
      "v6": {
        "title": "Prisma v6 (6.16.3)",
        "items": [
          "Direct PrismaClient usage",
          "Legacy engine architecture",
          "Baseline performance metrics"
        ]
      },
      "v7": {
        "title": "Prisma v7 (7.2.0)",
        "items": [
          "Adapter-based architecture",
          "@prisma/adapter-pg & adapter-better-sqlite3",
          "New engine optimizations"
        ]
      }
    },
    "benchmarkReports": {
      "title": "Automated benchmark reports",
      "description": "‡¶∏‡¶¨ benchmark results ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá generate ‡¶π‡¶Ø‡¶º‡ßá JSON ‡¶´‡¶æ‡¶á‡¶≤ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶ø‡¶§ ‡¶•‡¶æ‡¶ï‡ßá ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ transparency-‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:",
      "files": [
        "benchmark-results/v6-postgres-latest.json",
        "benchmark-results/v7-postgres-latest.json",
        "benchmark-results/v6-sqlite-latest.json",
        "benchmark-results/v7-sqlite-latest.json"
      ],
      "footer": "‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶´‡¶æ‡¶á‡¶≤‡ßá ‡¶•‡¶æ‡¶ï‡ßá: test name, Prisma execution time, generated SQL time, Drizzle time, speedup ratios, ‡¶è‡¶¨‡¶Ç ISO timestamp‡•§"
    },
    "cta": {
      "title": "Full test suite explore ‡¶ï‡¶∞‡ßÅ‡¶®",
      "subtitle": "‡¶∏‡¶¨ 137 tests open source‡•§ Test code, benchmarks, ‡¶è‡¶¨‡¶Ç validation logic review ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
      "button1": "View Test Suite ‚Üí",
      "button2": "See Benchmarks"
    }
  },
  "sqlPrevention": {
    "meta": {
      "title": "SQL Injection Prevention - Prisma-SQL Security",
      "description": "SQL injection prevention methodology using parameter binding, schema-based validation, and 137 security-focused tests (current suite)",
      "keywords": "sql injection prevention, parameterized queries, sql security, database security, prisma security"
    },
    "hero": {
      "badge": "üîí Security first",
      "title": "SQL Injection",
      "titleHighlight": "Prevention",
      "subtitle": "User-provided values are never interpolated into SQL text ‚Äî values are bound via parameter placeholders (dialect-specific, e.g. $1 or ?)"
    },
    "stats": [
      {
        "value": "100%",
        "label": "Parameter bound",
        "description": "All user-provided values use placeholders"
      },
      {
        "value": "Zero",
        "label": "Value interpolation",
        "description": "User data never appears in SQL text"
      },
      {
        "value": "Guaranteed",
        "label": "Order preservation",
        "description": "Placeholders map to params 1:1"
      },
      {
        "value": "137",
        "label": "Security tests",
        "description": "Injection attempt coverage (current suite)"
      }
    ],
    "threat": {
      "title": "Understanding SQL injection",
      "subtitle": "SQL injection remains one of the most critical web application vulnerabilities",
      "description": "SQL injection occurs when untrusted data is incorporated into SQL text without safe parameter binding. Attackers can manipulate query meaning to access unauthorized data, modify records, or trigger unintended operations.",
      "examples": {
        "title": "Common attack patterns",
        "items": [
          {
            "name": "Authentication bypass",
            "attack": "admin' OR '1'='1",
            "description": "Attempts to bypass login by making the WHERE condition always true"
          },
          {
            "name": "Data exfiltration",
            "attack": "' UNION SELECT password FROM users--",
            "description": "Uses UNION to attempt extracting data from other tables"
          },
          {
            "name": "Destructive commands",
            "attack": "'; DROP TABLE users; --",
            "description": "Attempts to append extra statements to delete data"
          },
          {
            "name": "Parameter order bug abuse",
            "attack": "Exploit: If placeholders and params are mismatched, authorization checks may use the wrong values",
            "description": "Example: WHERE userId=$1 AND isAdmin=$2, but params=[true, 123] instead of [123, true] can incorrectly grant admin access"
          }
        ]
      }
    },
    "protection": {
      "title": "Multi-layer protection strategy",
      "subtitle": "Every query passes through multiple security validation layers",
      "layers": [
        {
          "title": "Layer 1: Automatic parameter binding",
          "description": "All user-provided values are converted into bound parameters. Values do not enter SQL text as literals.",
          "guarantees": [
            "User values are represented using dialect-specific placeholders (e.g. $1 or ?)",
            "Array inputs are parameterized (expanded placeholders or array parameters depending on dialect/strategy)",
            "NULL and optional values handled without concatenating user input into SQL text",
            "Date/time values are parameterized",
            "JSON values are parameterized"
          ]
        },
        {
          "title": "Layer 2: Field name validation",
          "description": "Every field name is validated against the Prisma schema metadata before query generation.",
          "guarantees": [
            "Only schema-defined fields are allowed",
            "Relation filters validated via schema metadata",
            "No arbitrary field names accepted",
            "Unsupported/computed fields rejected where applicable",
            "Prototype pollution payloads are rejected (e.g. __proto__, constructor)"
          ]
        },
        {
          "title": "Layer 3: Identifier sanitization",
          "description": "Table names, column names, and aliases are validated and safely quoted/escaped as required.",
          "guarantees": [
            "Control characters rejected",
            "Reserved keywords are quoted when needed",
            "Schema qualification supported where configured",
            "Double-quote escaping (or dialect equivalent) for identifiers",
            "Maximum identifier length enforced per dialect"
          ]
        },
        {
          "title": "Layer 4: Operator validation",
          "description": "Only known, safe operators are allowed for each field type.",
          "guarantees": [
            "String operators: contains, startsWith, endsWith",
            "Numeric operators: lt, lte, gt, gte",
            "Array operators: in, notIn with type validation",
            "Logical operators: AND, OR, NOT validated structurally",
            "Unknown operators rejected immediately"
          ]
        },
        {
          "title": "Layer 5: Parameter order guarantee",
          "description": "Strict ordering ensures each placeholder maps to exactly one parameter in insertion order, preventing mismatches.",
          "guarantees": [
            "Sequential counter prevents reordering",
            "Lockstep SQL building and param array construction",
            "No intermediate buffer or reordering operations",
            "Test verification: generated SQL and params always align",
            "One-to-one correspondence: placeholder N ‚Üí params[N-1] (or equivalent mapping for the dialect)"
          ]
        }
      ]
    },
    "formalProofs": {
      "title": "Formal security guarantees",
      "subtitle": "Proof sketches for injection resistance under stated design assumptions (parameter binding, no raw-SQL bypass, correct driver usage)",
      "proofs": [
        {
          "title": "Theorem 1: Value isolation",
          "statement": "For all user-provided values V, there exists no execution path where V appears as SQL text in the generated query string.",
          "proof": "By construction, all code paths that handle user values call addParameter(value) which:\n1. Stores the value in a separate params array\n2. Returns a placeholder token for the SQL text\n3. Only the placeholder token is appended into the SQL string\n4. The database driver receives SQL text and parameter values separately\n‚à¥ User values are not parsed as SQL syntax",
          "code": "const addParameter = (params: any[], value: any) => {\n  params.push(value)\n  const index = params.length\n  return `$${index}`\n}"
        },
        {
          "title": "Theorem 2: Field name closure",
          "statement": "The set of field names F in any generated query is a subset of schema-defined fields S, i.e., F ‚äÜ S.",
          "proof": "For every field reference:\n1. Field name extracted from query object\n2. Lookup performed against schema metadata\n3. If the field does not exist in the schema, an error is thrown\n4. Only validated fields reach SQL generation\n‚à¥ Arbitrary field names cannot appear in SQL",
          "code": "const validateField = (field: string, model: Model) => {\n  if (!model.fields.has(field)) {\n    throw new Error(`Field ${field} does not exist`)\n  }\n  return model.fields.get(field)\n}"
        },
        {
          "title": "Theorem 3: Operator safety",
          "statement": "For any operator O applied to field F, O is a member of the allowed operators for F's type T.",
          "proof": "Operator validation algorithm:\n1. Extract field type T from schema\n2. Define allowed_ops(T) = { valid operators for type T }\n3. For operator O in query:\n   - If O ‚àâ allowed_ops(T), throw error\n   - Else apply operator using parameter binding\n‚à¥ Only type-appropriate operators can be used",
          "code": "const ALLOWED_OPS: Record<string, string[]> = {\n  String: ['contains', 'startsWith', 'endsWith'],\n  Int: ['lt', 'lte', 'gt', 'gte']\n}\nif (!ALLOWED_OPS[fieldType]?.includes(operator)) {\n  throw new Error('Invalid operator')\n}"
        },
        {
          "title": "Theorem 4: Identifier safety",
          "statement": "All SQL identifiers I are validated to prevent control characters and to ensure safe quoting/escaping per dialect.",
          "proof": "Identifier processing:\n1. Reject if contains control characters\n2. Escape internal quote characters per dialect rules\n3. Quote identifiers when required (reserved keywords or special characters)\n4. Enforce per-dialect identifier length limits\n‚à¥ Identifiers cannot break SQL syntax or introduce injected tokens",
          "code": "const quoteIdentifier = (id: string) => {\n  if (/[\\x00-\\x1F]/.test(id)) {\n    throw new Error('Invalid characters')\n  }\n  const escaped = id.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(id) || isReservedKeyword(id)\n  return needsQuoting ? `\"${escaped}\"` : id\n}"
        },
        {
          "title": "Theorem 5: Parameter order consistency",
          "statement": "For every placeholder position N emitted into the SQL text, params[N-1] contains the exact value intended for that position, with no reordering or mismatch.",
          "proof": "Parameter ordering guarantee:\n1. A single tracker maintains insertion order\n2. Each add() call appends the value to params and immediately emits the next placeholder token\n3. SQL text construction and params construction proceed in lockstep\n4. No intermediate reordering operations occur\n‚à¥ One-to-one correspondence is maintained throughout",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}\n\nconst tracker = new ParameterTracker()\nconst sql = `WHERE email = ${tracker.add(email)} AND age > ${tracker.add(age)}`\nconst params = tracker.getParams()"
        }
      ]
    },
    "testCoverage": {
      "title": "Comprehensive security test coverage",
      "subtitle": "137 tests validate protection against common SQL injection vectors and edge cases (current suite)",
      "categories": [
        {
          "title": "Value Parameterization (basic.test.ts)",
          "tests": [
            "Strings with quotes: user'with'quotes",
            "Strings with semicolons: user;extra",
            "SQL keywords as values: DROP TABLE users",
            "Complex injection: '; DROP TABLE users; --",
            "Union attacks: ' UNION SELECT * FROM users--",
            "Boolean attacks: admin' OR '1'='1",
            "Comment injection: test@example.com' -- comment"
          ]
        },
        {
          "title": "Field Name Validation (identifiers.test.ts)",
          "tests": [
            "Reject malicious field names in SELECT",
            "Reject malicious field names in WHERE",
            "Reject malicious field names in ORDER BY",
            "Reject SQL injection in field names",
            "Reject non-existent fields",
            "Reject prototype pollution: __proto__, constructor"
          ]
        },
        {
          "title": "LIKE Pattern Safety (like-patterns.test.ts)",
          "tests": [
            "Wildcard injection: %' OR '1'='1",
            "Underscore injection: test_' OR '1'='1",
            "Backslash handling: test\\\\'; DROP--",
            "Multiple wildcards: %_%'; DROP--",
            "Case insensitive injection: '; UNION SELECT--"
          ]
        },
        {
          "title": "Array Operator Safety (array-operators.test.ts)",
          "tests": [
            "IN with malicious arrays: ['; DROP--', 'UNION SELECT--']",
            "NOT IN with injection: ['; TRUNCATE--', 'DELETE FROM--']",
            "Empty array handling",
            "Large array validation (100+ items)",
            "Mixed type array handling"
          ]
        },
        {
          "title": "Edge Cases (edge-cases.test.ts)",
          "tests": [
            "Unicode injection: \\u0027 OR \\u00271\\u0027=\\u00271",
            "Hex-encoded injection: 0x31=0x31--",
            "URL encoded: %27%3B%20DROP%20TABLE",
            "Stacked queries: '; DROP TABLE users; SELECT",
            "Time-based blind (dialect-specific): WAITFOR DELAY '00:00:05'--",
            "UNION-based: UNION ALL SELECT null, password",
            "Second-order injection attempts"
          ]
        },
        {
          "title": "Parameter Order Verification (basic.test.ts)",
          "tests": [
            "Sequential placeholder positions",
            "Parameter array matches placeholder order",
            "Complex queries maintain order across conditions",
            "Nested OR/AND conditions preserve parameter sequence",
            "Relation filters maintain correct parameter mapping"
          ]
        }
      ]
    },
    "codeExamples": {
      "title": "Safe vs. Unsafe: Code Comparison",
      "unsafe": {
        "title": "‚ùå Unsafe: String Concatenation",
        "code": "const email = req.body.email\nconst sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\""
      },
      "safe": {
        "title": "‚úÖ Safe: Automatic Parameter Binding",
        "code": "const email = req.body.email\nconst { sql, params } = toSQL('User', 'findMany', {\n  where: { email }\n})\n\nconst result = { sql, params }"
      }
    },
    "implementation": {
      "title": "Implementation Details",
      "sections": [
        {
          "title": "Parameter Management",
          "description": "Centralized parameter tracking ensures every user-provided value is parameter bound and order-stable",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}"
        },
        {
          "title": "Field Validation",
          "description": "Schema-based validation prevents arbitrary field access",
          "code": "function validateField(\n  fieldName: string,\n  model: ModelInfo\n): FieldInfo {\n  const field = model.fields.get(fieldName)\n  if (!field) {\n    throw new Error(\n      `Field \"${fieldName}\" does not exist`\n    )\n  }\n  return field\n}"
        },
        {
          "title": "Identifier Quoting",
          "description": "Dialect-aware identifier validation and quoting prevents identifier-based syntax injection",
          "code": "function quoteIdentifier(identifier: string): string {\n  if (/[\\x00-\\x1F]/.test(identifier)) {\n    throw new Error('Invalid control characters')\n  }\n\n  const escaped = identifier.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(identifier) || isReservedKeyword(identifier)\n\n  if (needsQuoting) {\n    return `\"${escaped}\"`\n  }\n\n  return identifier\n}"
        }
      ]
    },
    "bestPractices": {
      "title": "Security Best Practices",
      "practices": [
        {
          "title": "Never Disable Validation",
          "description": "Do not bypass schema validation or field checking. These are critical security layers.",
          "do": "Use the library as designed with full validation",
          "dont": "Bypass schema validation or inject raw SQL into query text"
        },
        {
          "title": "Keep Schema Updated",
          "description": "Ensure your Prisma schema accurately reflects your database structure.",
          "do": "Run prisma db pull and prisma generate after schema changes",
          "dont": "Use outdated DMMF or schema definitions"
        },
        {
          "title": "Validate Input Types",
          "description": "TypeScript provides compile-time safety, but runtime validation adds defense in depth.",
          "do": "Use Prisma's generated types for query arguments",
          "dont": "Cast user input to any before passing to queries"
        },
        {
          "title": "Monitor Query Patterns",
          "description": "Log and monitor generated SQL and parameters in production to detect anomalies and misuse.",
          "do": "Enable query logging and review patterns",
          "dont": "Run in production without monitoring"
        }
      ]
    },
    "securityCallout": {
      "badge": "üîí Verified Secure",
      "title": "How do we prevent SQL injection?",
      "description": "Multi-layer validation with parameter binding, schema-based field checks, and 137 security tests (current suite)",
      "link": "View Security Details ‚Üí"
    },
    "cta": {
      "title": "Security Through Design",
      "subtitle": "SQL injection protection is built into every layer of this library. Review the security tests and implementation details directly.",
      "button1": "View Security Tests ‚Üí",
      "button2": "View Source Code"
    }
  }
}
