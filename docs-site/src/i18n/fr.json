{
  "meta": {
    "title": "Corrigez les requ√™tes Prisma lentes : lectures 2‚Äì7√ó plus rapides (jusqu‚Äô√† 53,5√ó) | Prisma-SQL",
    "description": "Prisma est lent ? Acc√©l√©rez les lectures Prisma lentes de 2‚Äì7√ó sans refactor. Contournez le chemin d‚Äôex√©cution de lecture de Prisma avec une ex√©cution SQL directe sur PostgreSQL et SQLite (jusqu‚Äô√† 53,5√ó sur les filtres de relation SQLite). Optimisation pr√™te pour la production pour des workloads Prisma domin√©s par la lecture.",
    "keywords": "slow prisma, prisma slow, prisma performance, fix slow prisma, speed up prisma, prisma optimization, prisma query speed, slow prisma queries, prisma performance issues, make prisma faster, postgresql, sqlite"
  },
  "header": { "cta": "Corriger Prisma lent ‚Üí" },
  "hero": {
    "badge": "üöÄ La solution pour Prisma lent",
    "title": "Corrigez les requ√™tes Prisma lentes",
    "titleHighlight": "Rendez votre API 2‚Äì7√ó plus rapide (jusqu‚Äô√† 53,5√ó)",
    "description": "Prisma est lent ? Vous n‚Äô√™tes pas seul. Vous aimez le DX de Prisma mais vous avez besoin de meilleures performances ?",
    "descriptionBold": "Acc√©l√©rez les requ√™tes Prisma lentes de 2‚Äì7√ó",
    "descriptionSuffix": "(jusqu‚Äô√† 53,5√ó sur les filtres de relation SQLite) sans modifier aucune requ√™te existante.",
    "cta1": "Acc√©l√©rer Prisma maintenant",
    "cta2": "Voir comment √ßa marche",
    "trustBadges": [
      "Lectures Prisma plus rapides",
      "Aucun changement de requ√™te",
      "Pr√™t pour la production",
      "137 tests E2E"
    ],
    "codeTitle": "Corriger Prisma lent en une ligne",
    "codeSnippet": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)\n\nconst users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
  },
  "stats": [
    {
      "value": "2‚Äì7√ó",
      "label": "Lectures Prisma plus rapides",
      "subtitle": "Acc√©l√©ration typique",
      "color": "text-accent"
    },
    {
      "value": "0",
      "label": "Changements de requ√™te",
      "subtitle": "Conservez vos appels Prisma existants",
      "color": "text-blue-600"
    },
    {
      "value": "137",
      "label": "Tests E2E",
      "subtitle": "Solution v√©rifi√©e",
      "color": "text-purple-600"
    },
    {
      "value": "100%",
      "label": "S√©curit√© des types",
      "subtitle": "M√™me API Prisma",
      "color": "text-pink-600"
    }
  ],
  "problem": {
    "title": "Pourquoi Prisma est-il lent ?",
    "subtitle": "Comprendre l‚Äô√©volution de Prisma et ses caract√©ristiques de performance aide √† expliquer pourquoi cette extension existe.",
    "historyTitle": "Le parcours de Prisma : d‚Äôabord le DX, puis la performance √† l‚Äô√©chelle",
    "history": [
      {
        "period": "üéØ 2019 : La naissance de Prisma moderne",
        "description": "Prisma 2 a √©t√© lanc√© en 2019, changeant le paysage des ORM TypeScript avec un acc√®s base de donn√©es typ√© et des types g√©n√©r√©s depuis votre sch√©ma. Prisma a introduit une architecture bas√©e sur un engine pour traduire et valider les requ√™tes, et fournir des garanties difficiles √† atteindre avec les ORM JavaScript traditionnels."
      },
      {
        "period": "‚ö° 2020‚Äì2022 : Croissance rapide et expansion des fonctionnalit√©s",
        "description": "Prisma a ajout√© des fonctionnalit√©s puissantes comme les √©critures imbriqu√©es, les transactions et le middleware. Le p√©rim√®tre fonctionnel s‚Äôest √©largi, mais chaque requ√™te payait toujours un co√ªt architectural : les requ√™tes sont repr√©sent√©es, valid√©es, ex√©cut√©es, puis les r√©sultats sont mis en forme pour correspondre √† l‚ÄôAPI Prisma."
      },
      {
        "period": "üìä 2023 : L‚Äôoverhead devient visible √† l‚Äô√©chelle",
        "description": "√Ä mesure que davantage d‚Äô√©quipes ont d√©ploy√© Prisma sur des workloads √† fort trafic, l‚Äôoverhead fixe par requ√™te est devenu mesurable. C‚Äôest le plus visible sur les endpoints domin√©s par la lecture, l‚Äôanalytics, les agr√©gations et les gros jeux de r√©sultats. Cet overhead n‚Äôest pas un bug ; c‚Äôest le co√ªt des garanties et du comportement d‚ÄôAPI de Prisma."
      },
      {
        "period": "üöÄ 2024‚Äì2025 : Le travail performance de Prisma continue",
        "description": "Prisma a livr√© des mises √† jour majeures ax√©es sur la performance et des changements d‚Äôengine. M√™me avec des am√©liorations, il subsiste un co√ªt in√©vitable pour parser, valider, planifier et mettre en forme les r√©sultats, compar√© √† l‚Äôex√©cution directe de SQL brut."
      },
      {
        "period": "üéØ 2026 : Sortie de l‚Äôextension prisma-sql",
        "description": "Cette extension se concentre sur les performances en lecture. Elle contourne le chemin d‚Äôex√©cution de lecture de Prisma pour findMany, findFirst, findUnique, count, aggregate et groupBy, tout en conservant Prisma pour les √©critures, les migrations, la gestion du sch√©ma et la g√©n√©ration de types. Validez la compatibilit√© avec votre version de Prisma avant d√©ploiement."
      }
    ],
    "whyExists": {
      "title": "üí° Pourquoi cette extension existe",
      "description": "Prisma a fait les bons choix architecturaux pour ses objectifs : s√©curit√© des types, exp√©rience d√©veloppeur et comportement multi-bases. Mais ces choix cr√©ent un overhead perceptible √† l‚Äô√©chelle. Cette extension ne remplace pas Prisma ‚Äî elle optimise les lectures pour les √©quipes qui veulent le DX de Prisma plus une ex√©cution plus rapide l√† o√π √ßa compte."
    },
    "technical": [
      {
        "title": "Couche de traduction des requ√™tes",
        "description": "Prisma traduit les entr√©es de requ√™te en SQL sp√©cifique au moteur. Cela permet un comportement multi-bases et la s√©mantique de l‚ÄôAPI Prisma, mais ajoute du temps de traitement avant que la base ne voie le SQL.",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Validation et garanties de type",
        "description": "Prisma valide les requ√™tes contre le sch√©ma et applique des garanties au niveau de l‚ÄôAPI. Ces garde-fous √©vitent certaines classes de bugs, mais ajoutent aussi de l‚Äôoverhead √† chaque requ√™te.",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Mise en forme des r√©sultats",
        "description": "Les r√©sultats sont mis en forme pour correspondre au comportement de l‚ÄôAPI Prisma. C‚Äôest excellent pour le DX et la coh√©rence, mais cela ajoute de la latence, surtout avec de gros jeux de r√©sultats et des includes complexes.",
        "iconPath": "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
      }
    ],
    "conclusion": "Cette extension compl√®te Prisma en offrant un chemin plus rapide pour les requ√™tes de lecture. Vous gardez tout ce que vous aimez dans Prisma tout en obtenant des lectures 2‚Äì7√ó plus rapides dans les cas typiques (et jusqu‚Äô√† 53,5√ó sur les filtres de relation SQLite) quand la performance compte."
  },
  "performance": {
    "title": "√Ä quelle vitesse ? Benchmarks r√©els",
    "subtitle": "Comparaison compl√®te entre Prisma v6, v7, Drizzle ORM et Prisma-SQL",
    "environment": "Environnement de benchmark : MacBook Pro M1 ‚Ä¢ PostgreSQL 15 ‚Ä¢ SQLite 3.43 ‚Ä¢ 137 cas de test par base de donn√©es",
    "databases": [
      {
        "name": "PostgreSQL",
        "color": "accent",
        "subtitle": "Moyenne sur 57 cas de test",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "2.10ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "1.95ms",
            "width": 93,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.08√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "1.40ms",
            "width": 67,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.50√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.90ms",
            "width": 43,
            "bgColor": "bg-gradient-to-r from-accent to-green-600",
            "color": "text-accent",
            "speedup": "2.34√ó"
          }
        ],
        "highlights": [
          {
            "label": "Distinct Queries",
            "value": "6.3√ó",
            "description": "vs Prisma v6"
          },
          {
            "label": "Relation Filters",
            "value": "5.5√ó",
            "description": "vs Prisma v6 (\"none\"-filtre)"
          }
        ]
      },
      {
        "name": "SQLite",
        "color": "purple",
        "subtitle": "Moyenne sur 56 cas de test",
        "comparisons": [
          {
            "label": "Prisma v6",
            "time": "5.48ms",
            "width": 100,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "isBaseline": true
          },
          {
            "label": "Prisma v7",
            "time": "4.12ms",
            "width": 75,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "1.33√ó"
          },
          {
            "label": "Drizzle ORM",
            "time": "2.11ms",
            "width": 39,
            "bgColor": "bg-gray-400",
            "color": "text-gray-700",
            "speedup": "2.60√ó"
          },
          {
            "label": "Prisma-SQL ‚ö°",
            "time": "0.73ms",
            "width": 13,
            "bgColor": "bg-gradient-to-r from-purple-500 to-pink-600",
            "color": "text-purple-600",
            "speedup": "7.50√ó"
          }
        ],
        "highlights": [
          {
            "label": "Simple Queries",
            "value": "12.6√ó",
            "description": "vs Prisma v6"
          },
          {
            "label": "Relation Filters",
            "value": "69.7√ó",
            "description": "vs Prisma v6 (\"none\"-filtre)"
          }
        ]
      }
    ],
    "footer": "Benchmarks bas√©s sur 137 tests E2E par base de donn√©es. Prisma v6.16.3, Prisma v7.2.0, Drizzle ORM latest.",
    "footerLink": "Voir les donn√©es compl√®tes du benchmark"
  },
  "howItWorks": {
    "title": "Comment elle optimise Prisma",
    "subtitle": "Contournez le chemin d‚Äôex√©cution de lecture de Prisma tout en conservant l‚ÄôAPI et les types Prisma",
    "steps": [
      {
        "title": "Intercepter les requ√™tes Prisma",
        "description": "L‚Äôextension intercepte les op√©rations de lecture (findMany, findFirst, findUnique, count, aggregate, groupBy) avant leur ex√©cution"
      },
      {
        "title": "G√©n√©rer du SQL optimis√©",
        "description": "Convertir les requ√™tes Prisma en SQL rapide et param√©tr√© avec des JOIN optimis√©s"
      },
      {
        "title": "Ex√©cuter directement",
        "description": "Ex√©cuter via postgres.js ou better-sqlite3 en contournant l‚Äôoverhead de lecture de Prisma"
      },
      {
        "title": "Renvoyer des r√©sultats compatibles",
        "description": "Les r√©sultats correspondent au format attendu par Prisma. Types, IntelliSense et code de requ√™te existant restent inchang√©s"
      }
    ],
    "codeExample": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})\n\n// Direct SQL execution for reads\n// Benchmarked around ~1.00ms on this workload\n// Same Prisma query code"
  },
  "features": {
    "title": "Pourquoi choisir cette extension Prisma ?",
    "subtitle": "Obtenez la vitesse d‚Äôex√©cution SQL brut en lecture tout en conservant l‚Äôexp√©rience d√©veloppeur de Prisma",
    "items": [
      {
        "title": "Acc√©l√©ration Prisma instantan√©e",
        "description": "Une configuration unique acc√©l√®re les lectures Prisma. Pas de refactor, pas de migration, pas d‚Äôarr√™t.",
        "color": "accent",
        "iconPath": "M13 10V3L4 14h7v7l9-11h-7z"
      },
      {
        "title": "Conservez vos types Prisma",
        "description": "Support TypeScript complet. Inf√©rence, autocompl√©tion et s√©curit√© √† la compilation pr√©serv√©es tout en acc√©l√©rant les lectures.",
        "color": "blue",
        "iconPath": "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
      },
      {
        "title": "Solution test√©e en production",
        "description": "137 tests E2E valident la compatibilit√© avec les versions r√©centes de Prisma. Utilis√©e pour acc√©l√©rer les lectures Prisma en production.",
        "color": "purple",
        "iconPath": "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"
      },
      {
        "title": "Support multi-bases",
        "description": "Optimisez les lectures Prisma sur PostgreSQL (dont Neon, Supabase) et SQLite.",
        "color": "pink",
        "iconPath": "M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
      },
      {
        "title": "Option pr√©compil√©e",
        "description": "Un g√©n√©rateur optionnel cr√©e du SQL au build, r√©duisant l‚Äôoverhead √† des microsecondes pour vos requ√™tes les plus chaudes.",
        "color": "yellow",
        "iconPath": "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
      },
      {
        "title": "Pr√™te pour le serverless (runtimes Node)",
        "description": "Fonctionne dans des runtimes Node serverless. Le support Edge runtime d√©pend des contraintes du runtime et du driver utilis√©.",
        "color": "green",
        "iconPath": "M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"
      }
    ]
  },
  "useCases": {
    "title": "Quand la performance Prisma compte le plus",
    "subtitle": "Sc√©narios courants o√π cette extension fait une vraie diff√©rence",
    "cases": [
      {
        "title": "üìä Analytics et reporting",
        "description": "Les agr√©gations et op√©rations groupBy Prisma b√©n√©ficient fortement de l‚Äôex√©cution SQL directe",
        "color": "blue",
        "benefits": [
          "groupBy 5√ó plus rapide acc√©l√®re les rapports",
          "Requ√™tes d‚Äôagr√©gation plus rapides",
          "M√©triques temps r√©el avec une latence plus faible"
        ]
      },
      {
        "title": "üöÄ APIs √† fort trafic",
        "description": "L‚Äôoverhead par requ√™te se cumule sous charge, surtout sur les endpoints domin√©s par la lecture",
        "color": "purple",
        "benefits": [
          "Temps de r√©ponse API plus faibles",
          "Plus de requ√™tes par instance",
          "Co√ªts d‚Äôinfrastructure r√©duits"
        ]
      },
      {
        "title": "‚òÅÔ∏è Fonctions serverless",
        "description": "Chaque milliseconde compte en serverless : r√©duisez la latence de lecture l√† o√π c‚Äôest critique",
        "color": "green",
        "benefits": [
          "Meilleurs p95/p99 en lecture",
          "Co√ªts plus bas gr√¢ce √† des lectures plus rapides",
          "Lectures plus rapides sans refactor"
        ]
      },
      {
        "title": "üì± Backends mobiles",
        "description": "Les utilisateurs per√ßoivent la latence : des lectures plus rapides am√©liorent imm√©diatement l‚ÄôUX per√ßue",
        "color": "orange",
        "benefits": [
          "Chargement du feed plus rapide",
          "Pagination plus rapide",
          "Interactions plus r√©actives"
        ]
      }
    ]
  },
  "installation": {
    "title": "Optimisez Prisma en 3 √©tapes",
    "subtitle": "Acc√©l√©rez les lectures Prisma en moins de 60 secondes",
    "steps": [
      {
        "title": "Installer l‚Äôextension Prisma",
        "language": "language-bash",
        "code": "# PostgreSQL\nnpm install prisma-sql postgres\n\n# SQLite\nnpm install prisma-sql better-sqlite3"
      },
      {
        "title": "Ajouter l‚Äôextension au Prisma Client",
        "language": "language-typescript",
        "code": "import { PrismaClient, Prisma } from '@prisma/client'\nimport { speedExtension, convertDMMFToModels } from 'prisma-sql'\nimport postgres from 'postgres'\n\nconst sql = postgres(process.env.DATABASE_URL)\nconst models = convertDMMFToModels(Prisma.dmmf.datamodel)\n\nconst prisma = new PrismaClient().$extends(\n  speedExtension({ postgres: sql, models })\n)"
      },
      {
        "title": "Utiliser Prisma normalement",
        "language": "language-typescript",
        "code": "const users = await prisma.user.findMany({\n  where: { status: 'ACTIVE' },\n  include: { posts: true }\n})"
      }
    ]
  },
  "faq": {
    "title": "FAQ performance Prisma",
    "subtitle": "Questions fr√©quentes sur l‚Äôoptimisation des lectures Prisma",
    "questions": [
      {
        "question": "Pourquoi Prisma a-t-il un overhead ?",
        "answer": "Prisma ajoute un overhead car il impl√©mente des garanties d‚ÄôAPI comme la validation bas√©e sur le sch√©ma, un comportement de requ√™te coh√©rent et la mise en forme des r√©sultats. Ces couches offrent une excellente exp√©rience d√©veloppeur mais co√ªtent du temps compar√© √† l‚Äôex√©cution directe de SQL brut."
      },
      {
        "question": "Comment optimiser des requ√™tes Prisma ?",
        "answer": "Optimisez les workloads Prisma domin√©s par la lecture en ajoutant cette extension. Elle ex√©cute les op√©rations de lecture via du SQL direct avec postgres.js ou better-sqlite3 tout en conservant l‚ÄôAPI et les types Prisma. Le setup est un petit changement d‚Äôinitialisation et ne n√©cessite pas de refactor de vos requ√™tes existantes."
      },
      {
        "question": "Prisma est-il plus lent que le SQL brut ?",
        "answer": "Pour de nombreux workloads en lecture, oui. Il y a un overhead architectural par rapport √† l‚Äôex√©cution de SQL brut. Cette extension vise √† conserver le DX de Prisma tout en r√©duisant la latence de lecture via l‚Äôex√©cution directe de SQL."
      },
      {
        "question": "Puis-je acc√©l√©rer Prisma sans modifier mes requ√™tes existantes ?",
        "answer": "Oui. Ajoutez l‚Äôextension une fois lors de l‚Äôinitialisation du Prisma Client et gardez votre code de requ√™tes Prisma inchang√©. Les lectures s‚Äôex√©cutent plus vite, tandis que l‚ÄôAPI, les types et le sch√©ma Prisma restent identiques."
      },
      {
        "question": "Est-ce que √ßa marche en production ?",
        "answer": "Oui. C‚Äôest valid√© par 137 tests E2E et con√ßu pour un usage en production. V√©rifiez toujours la compatibilit√© avec votre version de Prisma et ex√©cutez vos propres tests de r√©gression avant d√©ploiement."
      },
      {
        "question": "Qu‚Äôest-ce qui rend les agr√©gations Prisma plus lentes ?",
        "answer": "Les agr√©gations et groupBy amplifient souvent l‚Äôoverhead fixe (traitement des requ√™tes et mise en forme des r√©sultats) et peuvent impliquer de plus grands jeux de r√©sultats interm√©diaires. Cette extension optimise ces lectures en g√©n√©rant du SQL directement, ce qui r√©duit g√©n√©ralement la latence sur les endpoints riches en agr√©gations."
      }
    ]
  },
  "cta": {
    "title": "Pr√™t √† acc√©l√©rer Prisma ?",
    "subtitle": "Rejoignez les d√©veloppeurs qui optimisent les lectures Prisma : 2‚Äì7√ó plus rapide (jusqu‚Äô√† 53,5√ó)",
    "button1": "Installer Prisma-SQL",
    "button2": "Voir sur GitHub"
  },
  "footer": {
    "copyright": "¬© 2026 Prisma-SQL - Acc√©l√©rez les lectures Prisma de 2‚Äì7√ó (jusqu‚Äô√† 53,5√ó)",
    "tagline": "Rendre Prisma encore meilleur"
  },
  "testingCallout": {
    "badge": "‚úì Valid√©",
    "title": "Comment garantissons-nous la correction ?",
    "description": "Chaque requ√™te est valid√©e contre Prisma avec 137 tests end-to-end sur PostgreSQL et SQLite",
    "link": "Voir la m√©thodologie de test ‚Üí"
  },
  "testing": {
    "meta": {
      "title": "M√©thodologie de test - Prisma-SQL",
      "description": "Approche de test compl√®te : 137 tests E2E valident que le SQL g√©n√©r√© correspond exactement √† la sortie de Prisma",
      "keywords": "prisma testing, sql validation, e2e tests, orm testing, database testing"
    },
    "hero": {
      "badge": "üß™ Assurance qualit√©",
      "title": "Tests",
      "titleHighlight": "M√©thodologie",
      "subtitle": "137 tests end-to-end valident que chaque requ√™te SQL g√©n√©r√©e correspond exactement √† la sortie de Prisma"
    },
    "stats": [
      {
        "value": "137",
        "label": "Tests E2E",
        "description": "Chaque requ√™te valid√©e"
      },
      {
        "value": "100%",
        "label": "Couverture de parit√©",
        "description": "Correspondance byte-√†-byte"
      },
      {
        "value": "2",
        "label": "Moteurs de base",
        "description": "PostgreSQL & SQLite"
      },
      {
        "value": "3",
        "label": "Benchmarks ORM",
        "description": "Prisma v6/v7, Drizzle"
      }
    ],
    "validation": {
      "title": "Comment nous validons la correction",
      "subtitle": "Chaque test suit un processus rigoureux en 5 √©tapes pour garantir que le SQL g√©n√©r√© produit des r√©sultats identiques √† Prisma",
      "steps": [
        {
          "title": "G√©n√©rer du SQL √† partir d‚Äôune requ√™te Prisma",
          "description": "Parser les arguments Prisma et g√©n√©rer un SQL √©quivalent avec les m√™mes mod√®les et sch√©ma. Le SQL g√©n√©r√© utilise des requ√™tes param√©tr√©es pour la s√©curit√© et la performance."
        },
        {
          "title": "Ex√©cuter les deux requ√™tes en parall√®le",
          "description": "Ex√©cuter le SQL g√©n√©r√© directement via postgres.js ou better-sqlite3, et ex√©cuter la m√™me requ√™te via Prisma. Les deux ciblent le m√™me √©tat de base."
        },
        {
          "title": "Normaliser les r√©sultats",
          "description": "G√©rer les diff√©rences de type (BigInt vs Number, pr√©cision Decimal, s√©rialisation Date) et normaliser l‚Äôordre des cl√©s d‚Äôobjet pour une comparaison √©quitable."
        },
        {
          "title": "V√©rification d‚Äô√©galit√© profonde",
          "description": "V√©rifier une correspondance exacte : m√™me nombre de lignes, m√™mes valeurs de champs, m√™mes relations imbriqu√©es, m√™me ordre. Tout √©cart fait √©chouer le test."
        },
        {
          "title": "Mesurer la performance",
          "description": "Mesurer le temps d‚Äôex√©cution avec 5 warmups, puis moyenner 10‚Äì50 it√©rations par test. Comparer √† Prisma v6, Prisma v7 et Drizzle ORM."
        }
      ]
    },
    "advancedTechniques": {
      "title": "Techniques avanc√©es de validation",
      "dataTypes": {
        "title": "Normalisation des types de donn√©es",
        "items": [
          {
            "label": "Conversion BigInt",
            "description": "JavaScript BigInt ‚Üí Number pour comparaison"
          },
          {
            "label": "Gestion des Decimal",
            "description": "Prisma Decimal ‚Üí Float avec pr√©cision 10 chiffres"
          },
          {
            "label": "Normalisation des dates",
            "description": "Toutes les valeurs DateTime ‚Üí null (focus donn√©es, pas timestamps)"
          },
          {
            "label": "Parsing JSON",
            "description": "D√©tection et parsing automatique de cha√Ænes JSON"
          },
          {
            "label": "Tri des cl√©s d‚Äôobjet",
            "description": "Ordre alphab√©tique pour comparaison coh√©rente"
          }
        ]
      },
      "performance": {
        "title": "Benchmarking des performances",
        "items": [
          {
            "label": "Phase de warmup",
            "description": "5 it√©rations pour amorcer caches et JIT"
          },
          {
            "label": "It√©rations adaptatives",
            "description": "5‚Äì50 runs selon la complexit√©"
          },
          {
            "label": "Mesure isol√©e",
            "description": "Chaque type de requ√™te mesur√© ind√©pendamment"
          },
          {
            "label": "Comparaison multi-ORM",
            "description": "Prisma v6, v7, Drizzle, SQL g√©n√©r√©"
          },
          {
            "label": "Temps de g√©n√©ration SQL",
            "description": "Mesure s√©par√©e de l‚Äôoverhead de g√©n√©ration"
          }
        ]
      }
    },
    "coverage": {
      "title": "Couverture de test compl√®te",
      "subtitle": "Les tests couvrent chaque op√©ration de lecture Prisma √† plusieurs niveaux de complexit√©",
      "categories": [
        {
          "title": "Op√©rations de requ√™te",
          "items": [
            "findMany avec filtres complexes",
            "findFirst avec skip & pagination",
            "findUnique par ID & champs uniques",
            "count avec conditions WHERE",
            "aggregate (sum, avg, min, max)",
            "groupBy avec clauses HAVING"
          ]
        },
        {
          "title": "Sc√©narios complexes",
          "items": [
            "Includes imbriqu√©s (4 niveaux)",
            "Filtres de relation (some/every/none)",
            "Distinct avec window functions",
            "Pagination par curseur",
            "Select + include combin√©s",
            "Comptages de relation (_count)"
          ]
        },
        {
          "title": "Types de filtres",
          "items": [
            "Comparaison (lt/lte/gt/gte)",
            "Logique (AND/OR/NOT)",
            "Ops string (contains/startsWith)",
            "Tests NULL (is/isNot)",
            "IN/NOT IN tableaux",
            "Modes de sensibilit√© √† la casse"
          ]
        }
      ]
    },
    "databaseSpecific": {
      "postgres": {
        "title": "Tests PostgreSQL",
        "items": [
          "Recherches insensibles √† la casse via ILIKE",
          "Op√©rations JSON/JSONB",
          "Gestion des champs array",
          "Support des types composites",
          "Validation des window functions",
          "Tests d‚Äôisolation de transaction"
        ]
      },
      "sqlite": {
        "title": "Tests SQLite",
        "items": [
          "Pattern matching LIKE",
          "Validation extension JSON1",
          "√âmulation window functions",
          "Optimisation DISTINCT",
          "Corr√©lation de sous-requ√™tes",
          "Gestion de l‚Äôaffinit√© texte"
        ]
      }
    },
    "example": {
      "title": "Exemple de cas de test",
      "subtitle": "Voyez comment nous validons une requ√™te imbriqu√©e complexe avec des filtres de relation",
      "filename": "tests/e2e/postgres.test.ts",
      "code": "it('nested relation filter', () =>\n  runParityTest(\n    db,\n    benchmarkResults,\n    'findMany nested relation',\n    'Organization',\n    {\n      method: 'findMany',\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      }\n    },\n    () => db.prisma.organization.findMany({\n      where: {\n        projects: {\n          some: {\n            tasks: { some: { status: 'DONE' } }\n          }\n        }\n      },\n      orderBy: { id: 'asc' }\n    }),\n  )\n)\n\n// runParityTest internally:\n// 1. Calls generateSQL() with the args\n// 2. Executes generated SQL directly\n// 3. Executes Prisma query\n// 4. Normalizes both results\n// 5. Deep equality check - fails if any difference\n// 6. Benchmarks execution time"
    },
    "executionFlow": {
      "title": "Ce qui se passe pendant l‚Äôex√©cution des tests",
      "steps": [
        {
          "number": "1",
          "title": "G√©n√©ration de requ√™te (microsecondes)",
          "description": "generateSQL() parse les args Prisma et cr√©e du SQL param√©tr√©. Cette √©tape est benchmark√©e s√©par√©ment pour mesurer l‚Äôoverhead de g√©n√©ration."
        },
        {
          "number": "2",
          "title": "Ex√©cution en parall√®le (millisecondes)",
          "description": "Les deux requ√™tes frappent simultan√©ment le m√™me √©tat via Promise.all(), assurant une comparaison √©quitable et des conditions identiques."
        },
        {
          "number": "3",
          "title": "Normalisation profonde",
          "description": "Normalisation r√©cursive : BigInt‚ÜíNumber, Decimal‚ÜíFloat(10), Date‚Üínull, parsing JSON, tri des cl√©s. Cela garantit une comparaison byte-√†-byte."
        },
        {
          "number": "4",
          "title": "√âgalit√© stricte",
          "description": "Comparaison JSON stringify avec tol√©rance z√©ro. Tout √©cart de lignes, valeurs, objets imbriqu√©s ou ordre fait √©chouer le test avec un diff d√©taill√©."
        },
        {
          "number": "5",
          "title": "Mesure de performance",
          "description": "Apr√®s validation, 5‚Äì50 it√©rations mesurent le temps moyen. R√©sultats : Prisma v6, Prisma v7, Drizzle ORM, SQL g√©n√©r√©, et overhead de g√©n√©ration SQL."
        }
      ]
    },
    "multiVersion": {
      "title": "Validation multi-versions",
      "description": "Chaque test s‚Äôex√©cute sur Prisma v6 et v7 pour assurer la compatibilit√© :",
      "v6": {
        "title": "Prisma v6 (6.16.3)",
        "items": [
          "Usage direct de PrismaClient",
          "Architecture d‚Äôengine legacy",
          "M√©triques de r√©f√©rence"
        ]
      },
      "v7": {
        "title": "Prisma v7 (7.2.0)",
        "items": [
          "Architecture bas√©e sur adapters",
          "@prisma/adapter-pg & adapter-better-sqlite3",
          "Nouvelles optimisations d‚Äôengine"
        ]
      }
    },
    "benchmarkReports": {
      "title": "Rapports de benchmarks automatis√©s",
      "description": "Tous les r√©sultats de benchmarks sont g√©n√©r√©s automatiquement et stock√©s en JSON pour une transparence totale :",
      "files": [
        "benchmark-results/v6-postgres-latest.json",
        "benchmark-results/v7-postgres-latest.json",
        "benchmark-results/v6-sqlite-latest.json",
        "benchmark-results/v7-sqlite-latest.json"
      ],
      "footer": "Chaque fichier contient : nom de test, temps Prisma, temps SQL g√©n√©r√©, temps Drizzle, ratios de speedup, et timestamp ISO."
    },
    "cta": {
      "title": "Explorer la suite de tests compl√®te",
      "subtitle": "Les 137 tests sont open source. Consultez le code, les benchmarks et la logique de validation.",
      "button1": "Voir la suite de tests ‚Üí",
      "button2": "Voir les benchmarks"
    }
  },
  "sqlPrevention": {
    "meta": {
      "title": "Pr√©vention de l‚Äôinjection SQL - S√©curit√© Prisma-SQL",
      "description": "M√©thodologie de pr√©vention SQLi via liaison de param√®tres, validation bas√©e sur le sch√©ma et 137 tests s√©curit√© (suite actuelle)",
      "keywords": "sql injection prevention, parameterized queries, sql security, database security, prisma security"
    },
    "hero": {
      "badge": "üîí S√©curit√© d‚Äôabord",
      "title": "Injection SQL",
      "titleHighlight": "Pr√©vention",
      "subtitle": "Les valeurs fournies par l‚Äôutilisateur ne sont jamais interpol√©es dans le texte SQL ‚Äî elles sont li√©es via des placeholders de param√®tres (sp√©cifiques au dialecte, ex. $1 ou ?)"
    },
    "stats": [
      {
        "value": "100%",
        "label": "Li√© par param√®tres",
        "description": "Toutes les valeurs utilisateur utilisent des placeholders"
      },
      {
        "value": "Z√©ro",
        "label": "Interpolation de valeurs",
        "description": "Les donn√©es utilisateur n‚Äôapparaissent jamais dans le texte SQL"
      },
      {
        "value": "Garanti",
        "label": "Pr√©servation de l‚Äôordre",
        "description": "Les placeholders mappent aux params 1:1"
      },
      {
        "value": "137",
        "label": "Tests de s√©curit√©",
        "description": "Couverture des tentatives (suite actuelle)"
      }
    ],
    "threat": {
      "title": "Comprendre l‚Äôinjection SQL",
      "subtitle": "L‚Äôinjection SQL reste l‚Äôune des vuln√©rabilit√©s les plus critiques des applications web",
      "description": "Une injection SQL survient quand des donn√©es non fiables sont incorpor√©es au texte SQL sans liaison de param√®tres s√ªre. Des attaquants peuvent manipuler la requ√™te pour acc√©der √† des donn√©es non autoris√©es, modifier des enregistrements ou d√©clencher des op√©rations non d√©sir√©es.",
      "examples": {
        "title": "Sch√©mas d‚Äôattaque courants",
        "items": [
          {
            "name": "Contournement d‚Äôauthentification",
            "attack": "admin' OR '1'='1",
            "description": "Tente de contourner la connexion en rendant la condition WHERE toujours vraie"
          },
          {
            "name": "Exfiltration de donn√©es",
            "attack": "' UNION SELECT password FROM users--",
            "description": "Utilise UNION pour tenter d‚Äôextraire des donn√©es d‚Äôautres tables"
          },
          {
            "name": "Commandes destructrices",
            "attack": "'; DROP TABLE users; --",
            "description": "Tente d‚Äôajouter des instructions suppl√©mentaires pour supprimer des donn√©es"
          },
          {
            "name": "Abus de bug d‚Äôordre des param√®tres",
            "attack": "Exploit: If placeholders and params are mismatched, authorization checks may use the wrong values",
            "description": "Exemple : WHERE userId=$1 AND isAdmin=$2, mais params=[true, 123] au lieu de [123, true] peut accorder un acc√®s admin √† tort"
          }
        ]
      }
    },
    "protection": {
      "title": "Strat√©gie de protection multi-couches",
      "subtitle": "Chaque requ√™te passe par plusieurs couches de validation de s√©curit√©",
      "layers": [
        {
          "title": "Couche 1 : Liaison automatique des param√®tres",
          "description": "Toutes les valeurs utilisateur sont converties en param√®tres li√©s. Elles n‚Äôentrent pas dans le texte SQL comme litt√©raux.",
          "guarantees": [
            "Les valeurs utilisateur sont repr√©sent√©es par des placeholders sp√©cifiques au dialecte (ex. $1 ou ?)",
            "Les entr√©es tableau sont param√©tr√©es (placeholders √©tendus ou param√®tres array selon dialecte/strat√©gie)",
            "NULL et valeurs optionnelles g√©r√©s sans concat√©ner l‚Äôentr√©e utilisateur au texte SQL",
            "Valeurs date/heure param√©tr√©es",
            "Valeurs JSON param√©tr√©es"
          ]
        },
        {
          "title": "Couche 2 : Validation des noms de champs",
          "description": "Chaque nom de champ est valid√© contre les m√©tadonn√©es du sch√©ma Prisma avant g√©n√©ration.",
          "guarantees": [
            "Seuls les champs du sch√©ma sont autoris√©s",
            "Filtres de relation valid√©s via m√©tadonn√©es",
            "Aucun nom de champ arbitraire accept√©",
            "Champs non support√©s/calcul√©s rejet√©s si n√©cessaire",
            "Payloads de prototype pollution rejet√©s (ex. __proto__, constructor)"
          ]
        },
        {
          "title": "Couche 3 : Assainissement des identifiants",
          "description": "Noms de tables, colonnes et alias valid√©s et correctement quot√©s/√©chapp√©s.",
          "guarantees": [
            "Caract√®res de contr√¥le rejet√©s",
            "Mots r√©serv√©s quot√©s si n√©cessaire",
            "Qualification de sch√©ma support√©e si configur√©e",
            "√âchappement des guillemets (ou √©quivalent)",
            "Longueur max d‚Äôidentifiant appliqu√©e par dialecte"
          ]
        },
        {
          "title": "Couche 4 : Validation des op√©rateurs",
          "description": "Seuls des op√©rateurs connus et s√ªrs sont autoris√©s par type de champ.",
          "guarantees": [
            "Op√©rateurs string : contains, startsWith, endsWith",
            "Op√©rateurs num√©riques : lt, lte, gt, gte",
            "Op√©rateurs array : in, notIn avec validation de type",
            "Op√©rateurs logiques : AND, OR, NOT valid√©s structurellement",
            "Op√©rateurs inconnus rejet√©s imm√©diatement"
          ]
        },
        {
          "title": "Couche 5 : Garantie d‚Äôordre des param√®tres",
          "description": "Un ordre strict assure qu‚Äôun placeholder correspond √† exactement un param√®tre dans l‚Äôordre d‚Äôinsertion.",
          "guarantees": [
            "Compteur s√©quentiel emp√™che le r√©ordonnancement",
            "Construction SQL et tableau params en synchronisation",
            "Pas de buffer interm√©diaire ni r√©ordonnancement",
            "V√©rification par tests : SQL et params align√©s",
            "Correspondance 1‚Äì1 : placeholder N ‚Üí params[N-1] (ou √©quivalent selon dialecte)"
          ]
        }
      ]
    },
    "formalProofs": {
      "title": "Garanties formelles de s√©curit√©",
      "subtitle": "Esquisses de preuve de r√©sistance √† l‚Äôinjection sous hypoth√®ses (liaison de param√®tres, pas de bypass raw SQL, usage correct du driver)",
      "proofs": [
        {
          "title": "Th√©or√®me 1 : Isolation des valeurs",
          "statement": "For all user-provided values V, there exists no execution path where V appears as SQL text in the generated query string.",
          "proof": "By construction, all code paths that handle user values call addParameter(value) which:\n1. Stores the value in a separate params array\n2. Returns a placeholder token for the SQL text\n3. Only the placeholder token is appended into the SQL string\n4. The database driver receives SQL text and parameter values separately\n‚à¥ User values are not parsed as SQL syntax",
          "code": "const addParameter = (params: any[], value: any) => {\n  params.push(value)\n  const index = params.length\n  return `$${index}`\n}"
        },
        {
          "title": "Th√©or√®me 2 : Fermeture des noms de champs",
          "statement": "The set of field names F in any generated query is a subset of schema-defined fields S, i.e., F ‚äÜ S.",
          "proof": "For every field reference:\n1. Field name extracted from query object\n2. Lookup performed against schema metadata\n3. If the field does not exist in the schema, an error is thrown\n4. Only validated fields reach SQL generation\n‚à¥ Arbitrary field names cannot appear in SQL",
          "code": "const validateField = (field: string, model: Model) => {\n  if (!model.fields.has(field)) {\n    throw new Error(`Field ${field} does not exist`)\n  }\n  return model.fields.get(field)\n}"
        },
        {
          "title": "Th√©or√®me 3 : S√©curit√© des op√©rateurs",
          "statement": "For any operator O applied to field F, O is a member of the allowed operators for F's type T.",
          "proof": "Operator validation algorithm:\n1. Extract field type T from schema\n2. Define allowed_ops(T) = { valid operators for type T }\n3. For operator O in query:\n   - If O ‚àâ allowed_ops(T), throw error\n   - Else apply operator using parameter binding\n‚à¥ Only type-appropriate operators can be used",
          "code": "const ALLOWED_OPS: Record<string, string[]> = {\n  String: ['contains', 'startsWith', 'endsWith'],\n  Int: ['lt', 'lte', 'gt', 'gte']\n}\nif (!ALLOWED_OPS[fieldType]?.includes(operator)) {\n  throw new Error('Invalid operator')\n}"
        },
        {
          "title": "Th√©or√®me 4 : S√©curit√© des identifiants",
          "statement": "All SQL identifiers I are validated to prevent control characters and to ensure safe quoting/escaping per dialect.",
          "proof": "Identifier processing:\n1. Reject if contains control characters\n2. Escape internal quote characters per dialect rules\n3. Quote identifiers when required (reserved keywords or special characters)\n4. Enforce per-dialect identifier length limits\n‚à¥ Identifiers cannot break SQL syntax or introduce injected tokens",
          "code": "const quoteIdentifier = (id: string) => {\n  if (/[\\x00-\\x1F]/.test(id)) {\n    throw new Error('Invalid characters')\n  }\n  const escaped = id.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(id) || isReservedKeyword(id)\n  return needsQuoting ? `\"${escaped}\"` : id\n}"
        },
        {
          "title": "Th√©or√®me 5 : Coh√©rence d‚Äôordre des param√®tres",
          "statement": "For every placeholder position N emitted into the SQL text, params[N-1] contains the exact value intended for that position, with no reordering or mismatch.",
          "proof": "Parameter ordering guarantee:\n1. A single tracker maintains insertion order\n2. Each add() call appends the value to params and immediately emits the next placeholder token\n3. SQL text construction and params construction proceed in lockstep\n4. No intermediate reordering operations occur\n‚à¥ One-to-one correspondence is maintained throughout",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}\n\nconst tracker = new ParameterTracker()\nconst sql = `WHERE email = ${tracker.add(email)} AND age > ${tracker.add(age)}`\nconst params = tracker.getParams()"
        }
      ]
    },
    "testCoverage": {
      "title": "Couverture de tests de s√©curit√© compl√®te",
      "subtitle": "137 tests valident la protection contre les vecteurs SQLi courants et cas limites (suite actuelle)",
      "categories": [
        {
          "title": "Param√©trisation des valeurs (basic.test.ts)",
          "tests": [
            "Strings with quotes: user'with'quotes",
            "Strings with semicolons: user;extra",
            "SQL keywords as values: DROP TABLE users",
            "Complex injection: '; DROP TABLE users; --",
            "Union attacks: ' UNION SELECT * FROM users--",
            "Boolean attacks: admin' OR '1'='1",
            "Comment injection: test@example.com' -- comment"
          ]
        },
        {
          "title": "Validation des noms de champs (identifiers.test.ts)",
          "tests": [
            "Reject malicious field names in SELECT",
            "Reject malicious field names in WHERE",
            "Reject malicious field names in ORDER BY",
            "Reject SQL injection in field names",
            "Reject non-existent fields",
            "Reject prototype pollution: __proto__, constructor"
          ]
        },
        {
          "title": "S√©curit√© des patterns LIKE (like-patterns.test.ts)",
          "tests": [
            "Wildcard injection: %' OR '1'='1",
            "Underscore injection: test_' OR '1'='1",
            "Backslash handling: test\\\\'; DROP--",
            "Multiple wildcards: %_%'; DROP--",
            "Case insensitive injection: '; UNION SELECT--"
          ]
        },
        {
          "title": "S√©curit√© des op√©rateurs array (array-operators.test.ts)",
          "tests": [
            "IN with malicious arrays: ['; DROP--', 'UNION SELECT--']",
            "NOT IN with injection: ['; TRUNCATE--', 'DELETE FROM--']",
            "Empty array handling",
            "Large array validation (100+ items)",
            "Mixed type array handling"
          ]
        },
        {
          "title": "Cas limites (edge-cases.test.ts)",
          "tests": [
            "Unicode injection: \\u0027 OR \\u00271\\u0027=\\u00271",
            "Hex-encoded injection: 0x31=0x31--",
            "URL encoded: %27%3B%20DROP%20TABLE",
            "Stacked queries: '; DROP TABLE users; SELECT",
            "Time-based blind (dialect-specific): WAITFOR DELAY '00:00:05'--",
            "UNION-based: UNION ALL SELECT null, password",
            "Second-order injection attempts"
          ]
        },
        {
          "title": "V√©rification de l‚Äôordre des param√®tres (basic.test.ts)",
          "tests": [
            "Sequential placeholder positions",
            "Parameter array matches placeholder order",
            "Complex queries maintain order across conditions",
            "Nested OR/AND conditions preserve parameter sequence",
            "Relation filters maintain correct parameter mapping"
          ]
        }
      ]
    },
    "codeExamples": {
      "title": "S√ªr vs dangereux : comparaison de code",
      "unsafe": {
        "title": "‚ùå Dangereux : concat√©nation de cha√Ænes",
        "code": "const email = req.body.email\nconst sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\""
      },
      "safe": {
        "title": "‚úÖ S√ªr : liaison automatique des param√®tres",
        "code": "const email = req.body.email\nconst { sql, params } = toSQL('User', 'findMany', {\n  where: { email }\n})\n\nconst result = { sql, params }"
      }
    },
    "implementation": {
      "title": "D√©tails d‚Äôimpl√©mentation",
      "sections": [
        {
          "title": "Gestion des param√®tres",
          "description": "Un suivi centralis√© des param√®tres garantit que chaque valeur utilisateur est li√©e et stable en ordre",
          "code": "class ParameterTracker {\n  private params: any[] = []\n\n  add(value: any): string {\n    this.params.push(value)\n    return `$${this.params.length}`\n  }\n\n  getParams(): any[] {\n    return this.params\n  }\n}"
        },
        {
          "title": "Validation des champs",
          "description": "La validation bas√©e sur le sch√©ma emp√™che l‚Äôacc√®s arbitraire aux champs",
          "code": "function validateField(\n  fieldName: string,\n  model: ModelInfo\n): FieldInfo {\n  const field = model.fields.get(fieldName)\n  if (!field) {\n    throw new Error(\n      `Field \"${fieldName}\" does not exist`\n    )\n  }\n  return field\n}"
        },
        {
          "title": "Quotation des identifiants",
          "description": "Validation et quotation conscientes du dialecte pour pr√©venir l‚Äôinjection via identifiants",
          "code": "function quoteIdentifier(identifier: string): string {\n  if (/[\\x00-\\x1F]/.test(identifier)) {\n    throw new Error('Invalid control characters')\n  }\n\n  const escaped = identifier.replace(/\"/g, '\"\"')\n  const needsQuoting = /[^a-z0-9_]/i.test(identifier) || isReservedKeyword(identifier)\n\n  if (needsQuoting) {\n    return `\"${escaped}\"`\n  }\n\n  return identifier\n}"
        }
      ]
    },
    "bestPractices": {
      "title": "Bonnes pratiques de s√©curit√©",
      "practices": [
        {
          "title": "Ne jamais d√©sactiver la validation",
          "description": "Ne contournez pas la validation du sch√©ma ni les v√©rifications de champs. Ce sont des couches critiques.",
          "do": "Utiliser la biblioth√®que avec la validation compl√®te",
          "dont": "Contourner la validation du sch√©ma ou injecter du SQL brut dans le texte de requ√™te"
        },
        {
          "title": "Garder le sch√©ma √† jour",
          "description": "Assurez-vous que votre sch√©ma Prisma refl√®te fid√®lement la structure de la base.",
          "do": "Ex√©cuter prisma db pull et prisma generate apr√®s des changements",
          "dont": "Utiliser un DMMF ou sch√©ma obsol√®te"
        },
        {
          "title": "Valider les types d‚Äôentr√©e",
          "description": "TypeScript apporte la s√©curit√© √† la compilation, mais la validation runtime ajoute une d√©fense en profondeur.",
          "do": "Utiliser les types g√©n√©r√©s par Prisma",
          "dont": "Caster l‚Äôentr√©e utilisateur en any avant de la passer aux requ√™tes"
        },
        {
          "title": "Surveiller les patterns de requ√™tes",
          "description": "Logger et surveiller SQL g√©n√©r√© et param√®tres en production pour d√©tecter des anomalies.",
          "do": "Activer le logging et revoir les patterns",
          "dont": "Ex√©cuter en production sans monitoring"
        }
      ]
    },
    "securityCallout": {
      "badge": "üîí S√©curis√© et v√©rifi√©",
      "title": "Comment pr√©venir l‚Äôinjection SQL ?",
      "description": "Validation multi-couches avec liaison de param√®tres, v√©rifications bas√©es sur le sch√©ma et 137 tests s√©curit√© (suite actuelle)",
      "link": "Voir les d√©tails s√©curit√© ‚Üí"
    },
    "cta": {
      "title": "S√©curit√© par conception",
      "subtitle": "La protection contre l‚Äôinjection SQL est int√©gr√©e √† chaque couche. Consultez les tests s√©curit√© et les d√©tails d‚Äôimpl√©mentation.",
      "button1": "Voir les tests s√©curit√© ‚Üí",
      "button2": "Voir le code source"
    }
  }
}
