import {
  convertDMMFToModels,
  processAllDirectives,
} from '@dee-wan/schema-parser'
import { DMMF } from '@prisma/generator-helper'
import { mkdir, writeFile } from 'fs/promises'
import { join, resolve } from 'path'
import { generateSQL } from '.'
import { setGlobalDialect } from './sql-builder-dialect'

interface GenerateConfig {
  dialect: 'postgres' | 'sqlite'
  skipInvalid: boolean
}

interface GenerateClientOptions {
  datamodel: DMMF.Datamodel
  outputDir: string
  config: GenerateConfig
}

interface EnumInfo {
  mappings: Record<string, Record<string, string>>
  fieldTypes: Record<string, Record<string, string>>
}

function extractEnumMappings(datamodel: DMMF.Datamodel): EnumInfo {
  const mappings: Record<string, Record<string, string>> = {}
  const fieldTypes: Record<string, Record<string, string>> = {}

  for (const enumDef of datamodel.enums) {
    const enumMapping: Record<string, string> = {}

    for (const value of enumDef.values) {
      enumMapping[value.name] = value.dbName || value.name
    }

    if (Object.keys(enumMapping).length > 0) {
      mappings[enumDef.name] = enumMapping
    }
  }

  for (const model of datamodel.models) {
    fieldTypes[model.name] = {}

    for (const field of model.fields) {
      const baseType = field.type.replace(/\[\]|\?/g, '')
      if (mappings[baseType]) {
        fieldTypes[model.name][field.name] = baseType
      }
    }
  }

  return { mappings, fieldTypes }
}

export async function generateClient(options: GenerateClientOptions) {
  const { datamodel, outputDir, config } = options

  setGlobalDialect(config.dialect)

  const models = convertDMMFToModels(datamodel)

  const directiveResults = processAllDirectives(
    datamodel.models as unknown as DMMF.Model[],
    datamodel,
    {
      skipInvalid: config.skipInvalid,
    },
  )

  const queries = new Map<string, Map<string, Map<string, any>>>()

  for (const [modelName, result] of directiveResults) {
    if (result.directives.length === 0) continue

    if (!queries.has(modelName)) {
      queries.set(modelName, new Map())
    }

    const modelQueries = queries.get(modelName)!

    for (const directive of result.directives) {
      try {
        const method = directive.method
        const sqlDirective = generateSQL(directive)

        if (!modelQueries.has(method)) {
          modelQueries.set(method, new Map())
        }

        const methodQueriesMap = modelQueries.get(method)!

        const queryKey = createQueryKey(directive.query.processed)

        methodQueriesMap.set(queryKey, {
          sql: sqlDirective.sql,
          params: sqlDirective.staticParams,
          dynamicKeys: sqlDirective.dynamicKeys,
          paramMappings: sqlDirective.paramMappings,
        })
      } catch (error) {
        if (!config.skipInvalid) throw error
      }
    }
  }

  const absoluteOutputDir = resolve(process.cwd(), outputDir)
  await mkdir(absoluteOutputDir, { recursive: true })

  const code = generateCode(models, queries, config.dialect, datamodel)
  const outputPath = join(absoluteOutputDir, 'index.ts')

  await writeFile(outputPath, code)

  const totalQueries = Array.from(queries.values()).reduce(
    (sum, methodMap) =>
      sum +
      Array.from(methodMap.values()).reduce(
        (s, queryMap) => s + queryMap.size,
        0,
      ),
    0,
  )
  console.log(
    `âœ“ Generated ${queries.size} models, ${totalQueries} prebaked queries`,
  )
  console.log(`âœ“ Output: ${outputPath}`)
}

function createQueryKey(processedQuery: Record<string, unknown>): string {
  return JSON.stringify(processedQuery, (key, value) => {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      const sorted: Record<string, unknown> = {}
      for (const k of Object.keys(value).sort()) {
        sorted[k] = value[k]
      }
      return sorted
    }
    return value
  })
}

function generateCode(
  models: any[],
  queries: Map<string, Map<string, Map<string, any>>>,
  dialect: 'postgres' | 'sqlite',
  datamodel: DMMF.Datamodel,
): string {
  const cleanModels = models.map((model) => ({
    ...model,
    fields: model.fields.filter((f: any) => f !== undefined && f !== null),
  }))

  const { mappings, fieldTypes } = extractEnumMappings(datamodel)

  return `// Generated by @prisma-sql/generator - DO NOT EDIT
import { buildSQL, transformQueryResults, type PrismaMethod, type Model } from 'prisma-sql'

function normalizeValue(value: unknown): unknown {
  if (value instanceof Date) {
    return value.toISOString()
  }
  
  if (Array.isArray(value)) {
    return value.map(normalizeValue)
  }
  
  return value
}

export const MODELS: Model[] = ${JSON.stringify(cleanModels, null, 2)}

const ENUM_MAPPINGS: Record<string, Record<string, string>> = ${JSON.stringify(mappings, null, 2)}

const ENUM_FIELDS: Record<string, Record<string, string>> = ${JSON.stringify(fieldTypes, null, 2)}

const QUERIES: Record<string, Record<string, Record<string, {
  sql: string
  params: unknown[]
  dynamicKeys: string[]
  paramMappings: any[]
}>>> = ${formatQueries(queries)}

const DIALECT = ${JSON.stringify(dialect)}

function isDynamicParam(key: string): boolean {
  return key === 'skip' || key === 'take' || key === 'cursor'
}

function transformEnumInValue(value: unknown, enumType: string | undefined): unknown {
  if (!enumType || value === null || value === undefined) {
    return value
  }

  const mapping = ENUM_MAPPINGS[enumType]
  if (!mapping) {
    return value
  }

  if (Array.isArray(value)) {
    return value.map(v => {
      if (typeof v === 'string' && mapping[v] !== undefined) {
        return mapping[v]
      }
      return v
    })
  }

  if (typeof value === 'string' && mapping[value] !== undefined) {
    return mapping[value]
  }

  return value
}

function transformEnumValues(modelName: string, obj: any, currentPath: string[] = []): any {
  if (obj === null || obj === undefined) {
    return obj
  }
  
  if (Array.isArray(obj)) {
    return obj.map(item => transformEnumValues(modelName, item, currentPath))
  }
  
  if (typeof obj === 'object') {
    const transformed: any = {}
    const modelFields = ENUM_FIELDS[modelName] || {}
    
    for (const [key, value] of Object.entries(obj)) {
      const newPath = [...currentPath, key]
      
      const enumType = modelFields[key]
      
      if (enumType) {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          const transformedOperators: any = {}
          for (const [op, opValue] of Object.entries(value)) {
            transformedOperators[op] = transformEnumInValue(opValue, enumType)
          }
          transformed[key] = transformedOperators
        } else {
          transformed[key] = transformEnumInValue(value, enumType)
        }
      } else if (typeof value === 'object' && value !== null) {
        transformed[key] = transformEnumValues(modelName, value, newPath)
      } else {
        transformed[key] = value
      }
    }
    return transformed
  }
  
  return obj
}

function normalizeQuery(args: any): string {
  if (!args) return '{}'
  
  const normalized = JSON.parse(JSON.stringify(args))
  
  function replaceDynamicParams(obj: any): any {
    if (!obj || typeof obj !== 'object') return obj
    
    if (Array.isArray(obj)) {
      return obj.map(replaceDynamicParams)
    }
    
    const result: any = {}
    for (const [key, value] of Object.entries(obj)) {
      if (isDynamicParam(key)) {
        result[key] = \`__DYNAMIC_\${key}__\`
      } else {
        result[key] = replaceDynamicParams(value)
      }
    }
    return result
  }
  
  const withMarkers = replaceDynamicParams(normalized)
  
  function removeEmptyObjects(obj: any): any {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return obj
    
    const result: any = {}
    for (const [key, value] of Object.entries(obj)) {
      if (value && typeof value === 'object' && !Array.isArray(value) && Object.keys(value).length === 0) {
        continue
      }
      result[key] = removeEmptyObjects(value)
    }
    return result
  }
  
  const cleaned = removeEmptyObjects(withMarkers)
  
  return JSON.stringify(cleaned, (key, value) => {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      const sorted: Record<string, unknown> = {}
      for (const k of Object.keys(value).sort()) {
        sorted[k] = value[k]
      }
      return sorted
    }
    return value
  })
}

function extractDynamicParams(args: any, dynamicKeys: string[]): unknown[] {
  const params: unknown[] = []
  
  for (const key of dynamicKeys) {
    const parts = key.split(':')
    const lookupKey = parts.length === 2 ? parts[1] : key
    const value = args[lookupKey]
    
    if (value === undefined) {
      throw new Error(\`Missing required parameter: \${key}\`)
    }
    
    params.push(normalizeValue(value))
  }
  
  return params
}

async function executeQuery(client: any, sql: string, params: unknown[]): Promise<unknown[]> {
  if (DIALECT === 'postgres') {
    return await client.unsafe(sql, params)
  }
  
  const stmt = client.prepare(sql)
  
  if (sql.toUpperCase().includes('COUNT(*) AS')) {
    return [stmt.get(...params)]
  }
  
  return stmt.all(...params)
}

export function speedExtension(config: {
  postgres?: any
  sqlite?: any
  debug?: boolean
  onQuery?: (info: {
    model: string
    method: string
    sql: string
    params: unknown[]
    duration: number
    prebaked: boolean
  }) => void
}) {
  const { postgres, sqlite, debug, onQuery } = config

  if (!postgres && !sqlite) {
    throw new Error('speedExtension requires postgres or sqlite client')
  }

  const client = postgres || sqlite
  const actualDialect = postgres ? 'postgres' : 'sqlite'

  if (actualDialect !== DIALECT) {
    throw new Error(\`Generated code is for \${DIALECT}, but you provided \${actualDialect}\`)
  }

  return (prisma: any) => {
    const handleMethod = async function(this: any, method: PrismaMethod, args: any) {
      const modelName = this?.name || this?.$name
      const startTime = Date.now()

      const transformedArgs = transformEnumValues(modelName, args || {})

      const queryKey = normalizeQuery(transformedArgs)
      const prebakedQuery = QUERIES[modelName]?.[method]?.[queryKey]

      let sql: string
      let params: unknown[]
      let prebaked = false

      if (prebakedQuery) {
        sql = prebakedQuery.sql
        params = [...prebakedQuery.params, ...extractDynamicParams(transformedArgs, prebakedQuery.dynamicKeys)]
        prebaked = true
      } else {
        const model = MODELS.find((m) => m.name === modelName)
        
        if (!model) {
          return this.$parent[modelName][method](args)
        }

        const result = buildSQL(model, MODELS, method, transformedArgs, DIALECT)
        sql = result.sql
        params = result.params
      }

      if (debug) {
        console.log(\`[\${DIALECT}] \${modelName}.\${method} \${prebaked ? 'âš¡ PREBAKED' : 'ðŸ”¨ RUNTIME'}\`)
        console.log('SQL:', sql)
        console.log('Params:', params)
      }

      const results = await executeQuery(client, sql, params)
      const duration = Date.now() - startTime

      onQuery?.({
        model: modelName,
        method,
        sql,
        params,
        duration,
        prebaked,
      })

      return transformQueryResults(method, results)
    }

    return prisma.$extends({
      name: 'prisma-sql-generated',
      
      client: {
        $original: prisma,
      },

      model: {
        $allModels: {
          async findMany(args: any) {
            return handleMethod.call(this, 'findMany', args)
          },
          async findFirst(args: any) {
            return handleMethod.call(this, 'findFirst', args)
          },
          async findUnique(args: any) {
            return handleMethod.call(this, 'findUnique', args)
          },
          async count(args: any) {
            return handleMethod.call(this, 'count', args)
          },
          async aggregate(args: any) {
            return handleMethod.call(this, 'aggregate', args)
          },
          async groupBy(args: any) {
            return handleMethod.call(this, 'groupBy', args)
          },
        },
      },
    })
  }
}
`
}

function formatQueries(
  queries: Map<string, Map<string, Map<string, any>>>,
): string {
  if (queries.size === 0) {
    return '{}'
  }

  const modelEntries: string[] = []

  for (const [modelName, methodMap] of queries) {
    const methodEntries: string[] = []

    for (const [method, queryMap] of methodMap) {
      const queryEntries: string[] = []

      for (const [queryKey, query] of queryMap) {
        queryEntries.push(`    ${JSON.stringify(queryKey)}: {
      sql: ${JSON.stringify(query.sql)},
      params: ${JSON.stringify(query.params)},
      dynamicKeys: ${JSON.stringify(query.dynamicKeys)},
      paramMappings: ${JSON.stringify(query.paramMappings)},
    }`)
      }

      methodEntries.push(`    ${JSON.stringify(method)}: {
${queryEntries.join(',\n')}
    }`)
    }

    modelEntries.push(`  ${JSON.stringify(modelName)}: {
${methodEntries.join(',\n')}
  }`)
  }

  return `{
${modelEntries.join(',\n')}
}`
}
