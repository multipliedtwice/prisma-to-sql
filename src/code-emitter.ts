import {
  convertDMMFToModels,
  processAllDirectives,
} from '@dee-wan/schema-parser'
import { DMMF } from '@prisma/generator-helper'
import { mkdir, writeFile } from 'fs/promises'
import { join, resolve } from 'path'
import { generateSQL } from '.'
import { setGlobalDialect } from './sql-builder-dialect'

interface GenerateConfig {
  dialect: 'postgres' | 'sqlite'
  skipInvalid: boolean
}

interface GenerateClientOptions {
  datamodel: DMMF.Datamodel
  outputDir: string
  config: GenerateConfig
}

export async function generateClient(options: GenerateClientOptions) {
  const { datamodel, outputDir, config } = options

  setGlobalDialect(config.dialect)

  const models = convertDMMFToModels(datamodel)

  const directiveResults = processAllDirectives(
    datamodel.models as unknown as DMMF.Model[],
    datamodel,
    {
      skipInvalid: config.skipInvalid,
    },
  )

  const queries = new Map<string, Map<string, any>>()

  for (const [modelName, result] of directiveResults) {
    if (result.directives.length === 0) continue

    const modelQueries = new Map<string, any>()

    for (const directive of result.directives) {
      try {
        const sqlDirective = generateSQL(directive)
        const queryKey = JSON.stringify(
          directive.query.original,
          Object.keys(directive.query.original).sort(),
        )

        modelQueries.set(queryKey, {
          sql: sqlDirective.sql,
          params: sqlDirective.staticParams,
          dynamicKeys: sqlDirective.dynamicKeys,
          paramMappings: sqlDirective.paramMappings,
        })
      } catch (error) {
        if (!config.skipInvalid) throw error
      }
    }

    if (modelQueries.size > 0) {
      queries.set(modelName, modelQueries)
    }
  }

  const absoluteOutputDir = resolve(process.cwd(), outputDir)
  await mkdir(absoluteOutputDir, { recursive: true })

  const code = generateCode(models, queries, config.dialect)
  const outputPath = join(absoluteOutputDir, 'index.ts')

  await writeFile(outputPath, code)

  const totalQueries = Array.from(queries.values()).reduce(
    (sum, m) => sum + m.size,
    0,
  )
  console.log(`âœ“ Generated ${queries.size} models, ${totalQueries} queries`)
  console.log(`âœ“ Output: ${outputPath}`)
}

function generateCode(
  models: any[],
  queries: Map<string, Map<string, any>>,
  dialect: 'postgres' | 'sqlite',
): string {
  const cleanModels = models.map((model) => ({
    ...model,
    fields: model.fields.filter((f: any) => f !== undefined && f !== null),
  }))

  return `// Generated by @prisma-sql/generator - DO NOT EDIT
import { buildSQL, transformQueryResults, type PrismaMethod } from 'prisma-sql'

const MODELS = ${JSON.stringify(cleanModels, null, 2)}

const QUERIES: Record<string, Record<string, {
  sql: string
  params: unknown[]
  dynamicKeys: string[]
  paramMappings: any[]
}>> = ${formatQueries(queries)}

const DIALECT = ${JSON.stringify(dialect)}

function normalizeQuery(args: any): string {
  if (!args) return '{}'
  return JSON.stringify(args, Object.keys(args).sort())
}

function extractDynamicParams(args: any, dynamicKeys: string[]): unknown[] {
  const params: unknown[] = []
  
  for (const key of dynamicKeys) {
    const parts = key.split('.')
    let value: any = args
    
    for (const part of parts) {
      if (value === null || value === undefined) break
      value = value[part]
    }
    
    if (value === undefined) {
      throw new Error(\`Missing required parameter: \${key}\`)
    }
    
    params.push(value)
  }
  
  return params
}

async function executeQuery(client: any, sql: string, params: unknown[]): Promise<unknown[]> {
  if (DIALECT === 'postgres') {
    return await client.unsafe(sql, params)
  }
  
  const stmt = client.prepare(sql)
  
  if (sql.toUpperCase().includes('COUNT(*) AS')) {
    return [stmt.get(...params)]
  }
  
  return stmt.all(...params)
}

export function createExtension(config: {
  postgres?: any
  sqlite?: any
  debug?: boolean
  onQuery?: (info: {
    model: string
    method: string
    sql: string
    params: unknown[]
    duration: number
    prebaked: boolean
  }) => void
}) {
  const { postgres, sqlite, debug, onQuery } = config

  if (!postgres && !sqlite) {
    throw new Error('Extension requires postgres or sqlite client')
  }

  const client = postgres || sqlite
  const actualDialect = postgres ? 'postgres' : 'sqlite'

  if (actualDialect !== DIALECT) {
    throw new Error(\`Generated code is for \${DIALECT}, but you provided \${actualDialect}\`)
  }

  return (prisma: any) => {
    const handleMethod = async function(this: any, method: PrismaMethod, args: any) {
      const modelName = this?.name || this?.$name
      const startTime = Date.now()

      const queryKey = normalizeQuery(args)
      const prebakedQuery = QUERIES[modelName]?.[queryKey]

      let sql: string
      let params: unknown[]
      let prebaked = false

      if (prebakedQuery) {
        sql = prebakedQuery.sql
        params = [...prebakedQuery.params, ...extractDynamicParams(args, prebakedQuery.dynamicKeys)]
        prebaked = true
      } else {
        const model = MODELS.find((m: any) => m.name === modelName)
        
        if (!model) {
          return this.$parent[modelName][method](args)
        }

        const result = buildSQL(model, MODELS, method, args, DIALECT)
        sql = result.sql
        params = result.params
      }

      if (debug) {
        console.log(\`[\${DIALECT}] \${modelName}.\${method} \${prebaked ? 'âš¡ PREBAKED' : 'ðŸ”¨ RUNTIME'}\`)
        console.log('SQL:', sql)
        console.log('Params:', params)
      }

      const results = await executeQuery(client, sql, params)
      const duration = Date.now() - startTime

      onQuery?.({
        model: modelName,
        method,
        sql,
        params,
        duration,
        prebaked,
      })

      return transformQueryResults(method, results)
    }

    return prisma.$extends({
      name: 'prisma-sql-generated',
      
      client: {
        $original: prisma,
      },

      model: {
        $allModels: {
          async findMany(args: any) {
            return handleMethod.call(this, 'findMany', args)
          },
          async findFirst(args: any) {
            return handleMethod.call(this, 'findFirst', args)
          },
          async findUnique(args: any) {
            return handleMethod.call(this, 'findUnique', args)
          },
          async count(args: any) {
            return handleMethod.call(this, 'count', args)
          },
          async aggregate(args: any) {
            return handleMethod.call(this, 'aggregate', args)
          },
          async groupBy(args: any) {
            return handleMethod.call(this, 'groupBy', args)
          },
        },
      },
    })
  }
}
`
}

function formatQueries(queries: Map<string, Map<string, any>>): string {
  if (queries.size === 0) {
    return '{}'
  }

  const entries: string[] = []

  for (const [modelName, modelQueries] of queries) {
    const queryEntries: string[] = []

    for (const [queryKey, query] of modelQueries) {
      queryEntries.push(`  ${JSON.stringify(queryKey)}: {
    sql: ${JSON.stringify(query.sql)},
    params: ${JSON.stringify(query.params)},
    dynamicKeys: ${JSON.stringify(query.dynamicKeys)},
    paramMappings: ${JSON.stringify(query.paramMappings)},
  }`)
    }

    entries.push(`  ${JSON.stringify(modelName)}: {
${queryEntries.join(',\n')}
  }`)
  }

  return `{
${entries.join(',\n')}
}`
}
